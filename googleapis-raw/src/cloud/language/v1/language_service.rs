// This file is generated by rust-protobuf 2.7.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/cloud/language/v1/language_service.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_7_0;

#[derive(PartialEq,Clone,Default)]
pub struct Document {
    // message fields
    pub field_type: Document_Type,
    pub language: ::std::string::String,
    // message oneof groups
    pub source: ::std::option::Option<Document_oneof_source>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Document {
    fn default() -> &'a Document {
        <Document as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Document_oneof_source {
    content(::std::string::String),
    gcs_content_uri(::std::string::String),
}

impl Document {
    pub fn new() -> Document {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.Document.Type type = 1;


    pub fn get_field_type(&self) -> Document_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Document_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Document_Type) {
        self.field_type = v;
    }

    // string content = 2;


    pub fn get_content(&self) -> &str {
        match self.source {
            ::std::option::Option::Some(Document_oneof_source::content(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_content(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_content(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(Document_oneof_source::content(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(Document_oneof_source::content(v))
    }

    // Mutable pointer to the field.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Document_oneof_source::content(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(Document_oneof_source::content(::std::string::String::new()));
        }
        match self.source {
            ::std::option::Option::Some(Document_oneof_source::content(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        if self.has_content() {
            match self.source.take() {
                ::std::option::Option::Some(Document_oneof_source::content(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string gcs_content_uri = 3;


    pub fn get_gcs_content_uri(&self) -> &str {
        match self.source {
            ::std::option::Option::Some(Document_oneof_source::gcs_content_uri(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_gcs_content_uri(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_gcs_content_uri(&self) -> bool {
        match self.source {
            ::std::option::Option::Some(Document_oneof_source::gcs_content_uri(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_gcs_content_uri(&mut self, v: ::std::string::String) {
        self.source = ::std::option::Option::Some(Document_oneof_source::gcs_content_uri(v))
    }

    // Mutable pointer to the field.
    pub fn mut_gcs_content_uri(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Document_oneof_source::gcs_content_uri(_)) = self.source {
        } else {
            self.source = ::std::option::Option::Some(Document_oneof_source::gcs_content_uri(::std::string::String::new()));
        }
        match self.source {
            ::std::option::Option::Some(Document_oneof_source::gcs_content_uri(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_gcs_content_uri(&mut self) -> ::std::string::String {
        if self.has_gcs_content_uri() {
            match self.source.take() {
                ::std::option::Option::Some(Document_oneof_source::gcs_content_uri(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string language = 4;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Document {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(Document_oneof_source::content(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.source = ::std::option::Option::Some(Document_oneof_source::gcs_content_uri(is.read_string()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Document_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.language);
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &Document_oneof_source::content(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &Document_oneof_source::gcs_content_uri(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Document_Type::TYPE_UNSPECIFIED {
            os.write_enum(1, self.field_type.value())?;
        }
        if !self.language.is_empty() {
            os.write_string(4, &self.language)?;
        }
        if let ::std::option::Option::Some(ref v) = self.source {
            match v {
                &Document_oneof_source::content(ref v) => {
                    os.write_string(2, v)?;
                },
                &Document_oneof_source::gcs_content_uri(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Document {
        Document::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Document_Type>>(
                    "type",
                    |m: &Document| { &m.field_type },
                    |m: &mut Document| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "content",
                    Document::has_content,
                    Document::get_content,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "gcs_content_uri",
                    Document::has_gcs_content_uri,
                    Document::get_gcs_content_uri,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &Document| { &m.language },
                    |m: &mut Document| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Document>(
                    "Document",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Document {
        static mut instance: ::protobuf::lazy::Lazy<Document> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Document,
        };
        unsafe {
            instance.get(Document::new)
        }
    }
}

impl ::protobuf::Clear for Document {
    fn clear(&mut self) {
        self.field_type = Document_Type::TYPE_UNSPECIFIED;
        self.source = ::std::option::Option::None;
        self.source = ::std::option::Option::None;
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Document {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Document {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Document_Type {
    TYPE_UNSPECIFIED = 0,
    PLAIN_TEXT = 1,
    HTML = 2,
}

impl ::protobuf::ProtobufEnum for Document_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Document_Type> {
        match value {
            0 => ::std::option::Option::Some(Document_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Document_Type::PLAIN_TEXT),
            2 => ::std::option::Option::Some(Document_Type::HTML),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Document_Type] = &[
            Document_Type::TYPE_UNSPECIFIED,
            Document_Type::PLAIN_TEXT,
            Document_Type::HTML,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Document_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Document_Type {
}

impl ::std::default::Default for Document_Type {
    fn default() -> Self {
        Document_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Document_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Sentence {
    // message fields
    pub text: ::protobuf::SingularPtrField<TextSpan>,
    pub sentiment: ::protobuf::SingularPtrField<Sentiment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Sentence {
    fn default() -> &'a Sentence {
        <Sentence as ::protobuf::Message>::default_instance()
    }
}

impl Sentence {
    pub fn new() -> Sentence {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.TextSpan text = 1;


    pub fn get_text(&self) -> &TextSpan {
        self.text.as_ref().unwrap_or_else(|| TextSpan::default_instance())
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: TextSpan) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut TextSpan {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> TextSpan {
        self.text.take().unwrap_or_else(|| TextSpan::new())
    }

    // .google.cloud.language.v1.Sentiment sentiment = 2;


    pub fn get_sentiment(&self) -> &Sentiment {
        self.sentiment.as_ref().unwrap_or_else(|| Sentiment::default_instance())
    }
    pub fn clear_sentiment(&mut self) {
        self.sentiment.clear();
    }

    pub fn has_sentiment(&self) -> bool {
        self.sentiment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sentiment(&mut self, v: Sentiment) {
        self.sentiment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sentiment(&mut self) -> &mut Sentiment {
        if self.sentiment.is_none() {
            self.sentiment.set_default();
        }
        self.sentiment.as_mut().unwrap()
    }

    // Take field
    pub fn take_sentiment(&mut self) -> Sentiment {
        self.sentiment.take().unwrap_or_else(|| Sentiment::new())
    }
}

impl ::protobuf::Message for Sentence {
    fn is_initialized(&self) -> bool {
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sentiment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sentiment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sentiment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sentiment.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Sentence {
        Sentence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TextSpan>>(
                    "text",
                    |m: &Sentence| { &m.text },
                    |m: &mut Sentence| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sentiment>>(
                    "sentiment",
                    |m: &Sentence| { &m.sentiment },
                    |m: &mut Sentence| { &mut m.sentiment },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Sentence>(
                    "Sentence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Sentence {
        static mut instance: ::protobuf::lazy::Lazy<Sentence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Sentence,
        };
        unsafe {
            instance.get(Sentence::new)
        }
    }
}

impl ::protobuf::Clear for Sentence {
    fn clear(&mut self) {
        self.text.clear();
        self.sentiment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sentence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sentence {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Entity {
    // message fields
    pub name: ::std::string::String,
    pub field_type: Entity_Type,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub salience: f32,
    pub mentions: ::protobuf::RepeatedField<EntityMention>,
    pub sentiment: ::protobuf::SingularPtrField<Sentiment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Entity {
    fn default() -> &'a Entity {
        <Entity as ::protobuf::Message>::default_instance()
    }
}

impl Entity {
    pub fn new() -> Entity {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.cloud.language.v1.Entity.Type type = 2;


    pub fn get_field_type(&self) -> Entity_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Entity_Type::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Entity_Type) {
        self.field_type = v;
    }

    // repeated .google.cloud.language.v1.Entity.MetadataEntry metadata = 3;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // float salience = 4;


    pub fn get_salience(&self) -> f32 {
        self.salience
    }
    pub fn clear_salience(&mut self) {
        self.salience = 0.;
    }

    // Param is passed by value, moved
    pub fn set_salience(&mut self, v: f32) {
        self.salience = v;
    }

    // repeated .google.cloud.language.v1.EntityMention mentions = 5;


    pub fn get_mentions(&self) -> &[EntityMention] {
        &self.mentions
    }
    pub fn clear_mentions(&mut self) {
        self.mentions.clear();
    }

    // Param is passed by value, moved
    pub fn set_mentions(&mut self, v: ::protobuf::RepeatedField<EntityMention>) {
        self.mentions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mentions(&mut self) -> &mut ::protobuf::RepeatedField<EntityMention> {
        &mut self.mentions
    }

    // Take field
    pub fn take_mentions(&mut self) -> ::protobuf::RepeatedField<EntityMention> {
        ::std::mem::replace(&mut self.mentions, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.language.v1.Sentiment sentiment = 6;


    pub fn get_sentiment(&self) -> &Sentiment {
        self.sentiment.as_ref().unwrap_or_else(|| Sentiment::default_instance())
    }
    pub fn clear_sentiment(&mut self) {
        self.sentiment.clear();
    }

    pub fn has_sentiment(&self) -> bool {
        self.sentiment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sentiment(&mut self, v: Sentiment) {
        self.sentiment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sentiment(&mut self) -> &mut Sentiment {
        if self.sentiment.is_none() {
            self.sentiment.set_default();
        }
        self.sentiment.as_mut().unwrap()
    }

    // Take field
    pub fn take_sentiment(&mut self) -> Sentiment {
        self.sentiment.take().unwrap_or_else(|| Sentiment::new())
    }
}

impl ::protobuf::Message for Entity {
    fn is_initialized(&self) -> bool {
        for v in &self.mentions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sentiment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.salience = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mentions)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sentiment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.field_type != Entity_Type::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.metadata);
        if self.salience != 0. {
            my_size += 5;
        }
        for value in &self.mentions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.sentiment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.field_type != Entity_Type::UNKNOWN {
            os.write_enum(2, self.field_type.value())?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(3, &self.metadata, os)?;
        if self.salience != 0. {
            os.write_float(4, self.salience)?;
        }
        for v in &self.mentions {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.sentiment.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Entity {
        Entity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Entity| { &m.name },
                    |m: &mut Entity| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Entity_Type>>(
                    "type",
                    |m: &Entity| { &m.field_type },
                    |m: &mut Entity| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "metadata",
                    |m: &Entity| { &m.metadata },
                    |m: &mut Entity| { &mut m.metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "salience",
                    |m: &Entity| { &m.salience },
                    |m: &mut Entity| { &mut m.salience },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EntityMention>>(
                    "mentions",
                    |m: &Entity| { &m.mentions },
                    |m: &mut Entity| { &mut m.mentions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sentiment>>(
                    "sentiment",
                    |m: &Entity| { &m.sentiment },
                    |m: &mut Entity| { &mut m.sentiment },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Entity>(
                    "Entity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Entity {
        static mut instance: ::protobuf::lazy::Lazy<Entity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Entity,
        };
        unsafe {
            instance.get(Entity::new)
        }
    }
}

impl ::protobuf::Clear for Entity {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type = Entity_Type::UNKNOWN;
        self.metadata.clear();
        self.salience = 0.;
        self.mentions.clear();
        self.sentiment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Entity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Entity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Entity_Type {
    UNKNOWN = 0,
    PERSON = 1,
    LOCATION = 2,
    ORGANIZATION = 3,
    EVENT = 4,
    WORK_OF_ART = 5,
    CONSUMER_GOOD = 6,
    OTHER = 7,
}

impl ::protobuf::ProtobufEnum for Entity_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Entity_Type> {
        match value {
            0 => ::std::option::Option::Some(Entity_Type::UNKNOWN),
            1 => ::std::option::Option::Some(Entity_Type::PERSON),
            2 => ::std::option::Option::Some(Entity_Type::LOCATION),
            3 => ::std::option::Option::Some(Entity_Type::ORGANIZATION),
            4 => ::std::option::Option::Some(Entity_Type::EVENT),
            5 => ::std::option::Option::Some(Entity_Type::WORK_OF_ART),
            6 => ::std::option::Option::Some(Entity_Type::CONSUMER_GOOD),
            7 => ::std::option::Option::Some(Entity_Type::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Entity_Type] = &[
            Entity_Type::UNKNOWN,
            Entity_Type::PERSON,
            Entity_Type::LOCATION,
            Entity_Type::ORGANIZATION,
            Entity_Type::EVENT,
            Entity_Type::WORK_OF_ART,
            Entity_Type::CONSUMER_GOOD,
            Entity_Type::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Entity_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Entity_Type {
}

impl ::std::default::Default for Entity_Type {
    fn default() -> Self {
        Entity_Type::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Entity_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Token {
    // message fields
    pub text: ::protobuf::SingularPtrField<TextSpan>,
    pub part_of_speech: ::protobuf::SingularPtrField<PartOfSpeech>,
    pub dependency_edge: ::protobuf::SingularPtrField<DependencyEdge>,
    pub lemma: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Token {
    fn default() -> &'a Token {
        <Token as ::protobuf::Message>::default_instance()
    }
}

impl Token {
    pub fn new() -> Token {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.TextSpan text = 1;


    pub fn get_text(&self) -> &TextSpan {
        self.text.as_ref().unwrap_or_else(|| TextSpan::default_instance())
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: TextSpan) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut TextSpan {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> TextSpan {
        self.text.take().unwrap_or_else(|| TextSpan::new())
    }

    // .google.cloud.language.v1.PartOfSpeech part_of_speech = 2;


    pub fn get_part_of_speech(&self) -> &PartOfSpeech {
        self.part_of_speech.as_ref().unwrap_or_else(|| PartOfSpeech::default_instance())
    }
    pub fn clear_part_of_speech(&mut self) {
        self.part_of_speech.clear();
    }

    pub fn has_part_of_speech(&self) -> bool {
        self.part_of_speech.is_some()
    }

    // Param is passed by value, moved
    pub fn set_part_of_speech(&mut self, v: PartOfSpeech) {
        self.part_of_speech = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_part_of_speech(&mut self) -> &mut PartOfSpeech {
        if self.part_of_speech.is_none() {
            self.part_of_speech.set_default();
        }
        self.part_of_speech.as_mut().unwrap()
    }

    // Take field
    pub fn take_part_of_speech(&mut self) -> PartOfSpeech {
        self.part_of_speech.take().unwrap_or_else(|| PartOfSpeech::new())
    }

    // .google.cloud.language.v1.DependencyEdge dependency_edge = 3;


    pub fn get_dependency_edge(&self) -> &DependencyEdge {
        self.dependency_edge.as_ref().unwrap_or_else(|| DependencyEdge::default_instance())
    }
    pub fn clear_dependency_edge(&mut self) {
        self.dependency_edge.clear();
    }

    pub fn has_dependency_edge(&self) -> bool {
        self.dependency_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dependency_edge(&mut self, v: DependencyEdge) {
        self.dependency_edge = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dependency_edge(&mut self) -> &mut DependencyEdge {
        if self.dependency_edge.is_none() {
            self.dependency_edge.set_default();
        }
        self.dependency_edge.as_mut().unwrap()
    }

    // Take field
    pub fn take_dependency_edge(&mut self) -> DependencyEdge {
        self.dependency_edge.take().unwrap_or_else(|| DependencyEdge::new())
    }

    // string lemma = 4;


    pub fn get_lemma(&self) -> &str {
        &self.lemma
    }
    pub fn clear_lemma(&mut self) {
        self.lemma.clear();
    }

    // Param is passed by value, moved
    pub fn set_lemma(&mut self, v: ::std::string::String) {
        self.lemma = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lemma(&mut self) -> &mut ::std::string::String {
        &mut self.lemma
    }

    // Take field
    pub fn take_lemma(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lemma, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Token {
    fn is_initialized(&self) -> bool {
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.part_of_speech {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dependency_edge {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.part_of_speech)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dependency_edge)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lemma)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.part_of_speech.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dependency_edge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.lemma.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.lemma);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.part_of_speech.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dependency_edge.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.lemma.is_empty() {
            os.write_string(4, &self.lemma)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Token {
        Token::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TextSpan>>(
                    "text",
                    |m: &Token| { &m.text },
                    |m: &mut Token| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PartOfSpeech>>(
                    "part_of_speech",
                    |m: &Token| { &m.part_of_speech },
                    |m: &mut Token| { &mut m.part_of_speech },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DependencyEdge>>(
                    "dependency_edge",
                    |m: &Token| { &m.dependency_edge },
                    |m: &mut Token| { &mut m.dependency_edge },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lemma",
                    |m: &Token| { &m.lemma },
                    |m: &mut Token| { &mut m.lemma },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Token>(
                    "Token",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Token {
        static mut instance: ::protobuf::lazy::Lazy<Token> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Token,
        };
        unsafe {
            instance.get(Token::new)
        }
    }
}

impl ::protobuf::Clear for Token {
    fn clear(&mut self) {
        self.text.clear();
        self.part_of_speech.clear();
        self.dependency_edge.clear();
        self.lemma.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Token {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Token {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Sentiment {
    // message fields
    pub magnitude: f32,
    pub score: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Sentiment {
    fn default() -> &'a Sentiment {
        <Sentiment as ::protobuf::Message>::default_instance()
    }
}

impl Sentiment {
    pub fn new() -> Sentiment {
        ::std::default::Default::default()
    }

    // float magnitude = 2;


    pub fn get_magnitude(&self) -> f32 {
        self.magnitude
    }
    pub fn clear_magnitude(&mut self) {
        self.magnitude = 0.;
    }

    // Param is passed by value, moved
    pub fn set_magnitude(&mut self, v: f32) {
        self.magnitude = v;
    }

    // float score = 3;


    pub fn get_score(&self) -> f32 {
        self.score
    }
    pub fn clear_score(&mut self) {
        self.score = 0.;
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: f32) {
        self.score = v;
    }
}

impl ::protobuf::Message for Sentiment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.magnitude = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.score = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.magnitude != 0. {
            my_size += 5;
        }
        if self.score != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.magnitude != 0. {
            os.write_float(2, self.magnitude)?;
        }
        if self.score != 0. {
            os.write_float(3, self.score)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Sentiment {
        Sentiment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "magnitude",
                    |m: &Sentiment| { &m.magnitude },
                    |m: &mut Sentiment| { &mut m.magnitude },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "score",
                    |m: &Sentiment| { &m.score },
                    |m: &mut Sentiment| { &mut m.score },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Sentiment>(
                    "Sentiment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Sentiment {
        static mut instance: ::protobuf::lazy::Lazy<Sentiment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Sentiment,
        };
        unsafe {
            instance.get(Sentiment::new)
        }
    }
}

impl ::protobuf::Clear for Sentiment {
    fn clear(&mut self) {
        self.magnitude = 0.;
        self.score = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sentiment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sentiment {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PartOfSpeech {
    // message fields
    pub tag: PartOfSpeech_Tag,
    pub aspect: PartOfSpeech_Aspect,
    pub case: PartOfSpeech_Case,
    pub form: PartOfSpeech_Form,
    pub gender: PartOfSpeech_Gender,
    pub mood: PartOfSpeech_Mood,
    pub number: PartOfSpeech_Number,
    pub person: PartOfSpeech_Person,
    pub proper: PartOfSpeech_Proper,
    pub reciprocity: PartOfSpeech_Reciprocity,
    pub tense: PartOfSpeech_Tense,
    pub voice: PartOfSpeech_Voice,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PartOfSpeech {
    fn default() -> &'a PartOfSpeech {
        <PartOfSpeech as ::protobuf::Message>::default_instance()
    }
}

impl PartOfSpeech {
    pub fn new() -> PartOfSpeech {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.PartOfSpeech.Tag tag = 1;


    pub fn get_tag(&self) -> PartOfSpeech_Tag {
        self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag = PartOfSpeech_Tag::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: PartOfSpeech_Tag) {
        self.tag = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Aspect aspect = 2;


    pub fn get_aspect(&self) -> PartOfSpeech_Aspect {
        self.aspect
    }
    pub fn clear_aspect(&mut self) {
        self.aspect = PartOfSpeech_Aspect::ASPECT_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_aspect(&mut self, v: PartOfSpeech_Aspect) {
        self.aspect = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Case case = 3;


    pub fn get_case(&self) -> PartOfSpeech_Case {
        self.case
    }
    pub fn clear_case(&mut self) {
        self.case = PartOfSpeech_Case::CASE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_case(&mut self, v: PartOfSpeech_Case) {
        self.case = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Form form = 4;


    pub fn get_form(&self) -> PartOfSpeech_Form {
        self.form
    }
    pub fn clear_form(&mut self) {
        self.form = PartOfSpeech_Form::FORM_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_form(&mut self, v: PartOfSpeech_Form) {
        self.form = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Gender gender = 5;


    pub fn get_gender(&self) -> PartOfSpeech_Gender {
        self.gender
    }
    pub fn clear_gender(&mut self) {
        self.gender = PartOfSpeech_Gender::GENDER_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_gender(&mut self, v: PartOfSpeech_Gender) {
        self.gender = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Mood mood = 6;


    pub fn get_mood(&self) -> PartOfSpeech_Mood {
        self.mood
    }
    pub fn clear_mood(&mut self) {
        self.mood = PartOfSpeech_Mood::MOOD_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_mood(&mut self, v: PartOfSpeech_Mood) {
        self.mood = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Number number = 7;


    pub fn get_number(&self) -> PartOfSpeech_Number {
        self.number
    }
    pub fn clear_number(&mut self) {
        self.number = PartOfSpeech_Number::NUMBER_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: PartOfSpeech_Number) {
        self.number = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Person person = 8;


    pub fn get_person(&self) -> PartOfSpeech_Person {
        self.person
    }
    pub fn clear_person(&mut self) {
        self.person = PartOfSpeech_Person::PERSON_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_person(&mut self, v: PartOfSpeech_Person) {
        self.person = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Proper proper = 9;


    pub fn get_proper(&self) -> PartOfSpeech_Proper {
        self.proper
    }
    pub fn clear_proper(&mut self) {
        self.proper = PartOfSpeech_Proper::PROPER_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_proper(&mut self, v: PartOfSpeech_Proper) {
        self.proper = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Reciprocity reciprocity = 10;


    pub fn get_reciprocity(&self) -> PartOfSpeech_Reciprocity {
        self.reciprocity
    }
    pub fn clear_reciprocity(&mut self) {
        self.reciprocity = PartOfSpeech_Reciprocity::RECIPROCITY_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_reciprocity(&mut self, v: PartOfSpeech_Reciprocity) {
        self.reciprocity = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Tense tense = 11;


    pub fn get_tense(&self) -> PartOfSpeech_Tense {
        self.tense
    }
    pub fn clear_tense(&mut self) {
        self.tense = PartOfSpeech_Tense::TENSE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_tense(&mut self, v: PartOfSpeech_Tense) {
        self.tense = v;
    }

    // .google.cloud.language.v1.PartOfSpeech.Voice voice = 12;


    pub fn get_voice(&self) -> PartOfSpeech_Voice {
        self.voice
    }
    pub fn clear_voice(&mut self) {
        self.voice = PartOfSpeech_Voice::VOICE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_voice(&mut self, v: PartOfSpeech_Voice) {
        self.voice = v;
    }
}

impl ::protobuf::Message for PartOfSpeech {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.tag, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.aspect, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.case, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.form, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.gender, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mood, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.number, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.person, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.proper, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.reciprocity, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.tense, 11, &mut self.unknown_fields)?
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.voice, 12, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tag != PartOfSpeech_Tag::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.tag);
        }
        if self.aspect != PartOfSpeech_Aspect::ASPECT_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.aspect);
        }
        if self.case != PartOfSpeech_Case::CASE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(3, self.case);
        }
        if self.form != PartOfSpeech_Form::FORM_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(4, self.form);
        }
        if self.gender != PartOfSpeech_Gender::GENDER_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(5, self.gender);
        }
        if self.mood != PartOfSpeech_Mood::MOOD_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(6, self.mood);
        }
        if self.number != PartOfSpeech_Number::NUMBER_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(7, self.number);
        }
        if self.person != PartOfSpeech_Person::PERSON_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(8, self.person);
        }
        if self.proper != PartOfSpeech_Proper::PROPER_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(9, self.proper);
        }
        if self.reciprocity != PartOfSpeech_Reciprocity::RECIPROCITY_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(10, self.reciprocity);
        }
        if self.tense != PartOfSpeech_Tense::TENSE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(11, self.tense);
        }
        if self.voice != PartOfSpeech_Voice::VOICE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(12, self.voice);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.tag != PartOfSpeech_Tag::UNKNOWN {
            os.write_enum(1, self.tag.value())?;
        }
        if self.aspect != PartOfSpeech_Aspect::ASPECT_UNKNOWN {
            os.write_enum(2, self.aspect.value())?;
        }
        if self.case != PartOfSpeech_Case::CASE_UNKNOWN {
            os.write_enum(3, self.case.value())?;
        }
        if self.form != PartOfSpeech_Form::FORM_UNKNOWN {
            os.write_enum(4, self.form.value())?;
        }
        if self.gender != PartOfSpeech_Gender::GENDER_UNKNOWN {
            os.write_enum(5, self.gender.value())?;
        }
        if self.mood != PartOfSpeech_Mood::MOOD_UNKNOWN {
            os.write_enum(6, self.mood.value())?;
        }
        if self.number != PartOfSpeech_Number::NUMBER_UNKNOWN {
            os.write_enum(7, self.number.value())?;
        }
        if self.person != PartOfSpeech_Person::PERSON_UNKNOWN {
            os.write_enum(8, self.person.value())?;
        }
        if self.proper != PartOfSpeech_Proper::PROPER_UNKNOWN {
            os.write_enum(9, self.proper.value())?;
        }
        if self.reciprocity != PartOfSpeech_Reciprocity::RECIPROCITY_UNKNOWN {
            os.write_enum(10, self.reciprocity.value())?;
        }
        if self.tense != PartOfSpeech_Tense::TENSE_UNKNOWN {
            os.write_enum(11, self.tense.value())?;
        }
        if self.voice != PartOfSpeech_Voice::VOICE_UNKNOWN {
            os.write_enum(12, self.voice.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PartOfSpeech {
        PartOfSpeech::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Tag>>(
                    "tag",
                    |m: &PartOfSpeech| { &m.tag },
                    |m: &mut PartOfSpeech| { &mut m.tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Aspect>>(
                    "aspect",
                    |m: &PartOfSpeech| { &m.aspect },
                    |m: &mut PartOfSpeech| { &mut m.aspect },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Case>>(
                    "case",
                    |m: &PartOfSpeech| { &m.case },
                    |m: &mut PartOfSpeech| { &mut m.case },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Form>>(
                    "form",
                    |m: &PartOfSpeech| { &m.form },
                    |m: &mut PartOfSpeech| { &mut m.form },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Gender>>(
                    "gender",
                    |m: &PartOfSpeech| { &m.gender },
                    |m: &mut PartOfSpeech| { &mut m.gender },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Mood>>(
                    "mood",
                    |m: &PartOfSpeech| { &m.mood },
                    |m: &mut PartOfSpeech| { &mut m.mood },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Number>>(
                    "number",
                    |m: &PartOfSpeech| { &m.number },
                    |m: &mut PartOfSpeech| { &mut m.number },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Person>>(
                    "person",
                    |m: &PartOfSpeech| { &m.person },
                    |m: &mut PartOfSpeech| { &mut m.person },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Proper>>(
                    "proper",
                    |m: &PartOfSpeech| { &m.proper },
                    |m: &mut PartOfSpeech| { &mut m.proper },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Reciprocity>>(
                    "reciprocity",
                    |m: &PartOfSpeech| { &m.reciprocity },
                    |m: &mut PartOfSpeech| { &mut m.reciprocity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Tense>>(
                    "tense",
                    |m: &PartOfSpeech| { &m.tense },
                    |m: &mut PartOfSpeech| { &mut m.tense },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PartOfSpeech_Voice>>(
                    "voice",
                    |m: &PartOfSpeech| { &m.voice },
                    |m: &mut PartOfSpeech| { &mut m.voice },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PartOfSpeech>(
                    "PartOfSpeech",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PartOfSpeech {
        static mut instance: ::protobuf::lazy::Lazy<PartOfSpeech> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PartOfSpeech,
        };
        unsafe {
            instance.get(PartOfSpeech::new)
        }
    }
}

impl ::protobuf::Clear for PartOfSpeech {
    fn clear(&mut self) {
        self.tag = PartOfSpeech_Tag::UNKNOWN;
        self.aspect = PartOfSpeech_Aspect::ASPECT_UNKNOWN;
        self.case = PartOfSpeech_Case::CASE_UNKNOWN;
        self.form = PartOfSpeech_Form::FORM_UNKNOWN;
        self.gender = PartOfSpeech_Gender::GENDER_UNKNOWN;
        self.mood = PartOfSpeech_Mood::MOOD_UNKNOWN;
        self.number = PartOfSpeech_Number::NUMBER_UNKNOWN;
        self.person = PartOfSpeech_Person::PERSON_UNKNOWN;
        self.proper = PartOfSpeech_Proper::PROPER_UNKNOWN;
        self.reciprocity = PartOfSpeech_Reciprocity::RECIPROCITY_UNKNOWN;
        self.tense = PartOfSpeech_Tense::TENSE_UNKNOWN;
        self.voice = PartOfSpeech_Voice::VOICE_UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PartOfSpeech {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Tag {
    UNKNOWN = 0,
    ADJ = 1,
    ADP = 2,
    ADV = 3,
    CONJ = 4,
    DET = 5,
    NOUN = 6,
    NUM = 7,
    PRON = 8,
    PRT = 9,
    PUNCT = 10,
    VERB = 11,
    X = 12,
    AFFIX = 13,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Tag {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Tag> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Tag::UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Tag::ADJ),
            2 => ::std::option::Option::Some(PartOfSpeech_Tag::ADP),
            3 => ::std::option::Option::Some(PartOfSpeech_Tag::ADV),
            4 => ::std::option::Option::Some(PartOfSpeech_Tag::CONJ),
            5 => ::std::option::Option::Some(PartOfSpeech_Tag::DET),
            6 => ::std::option::Option::Some(PartOfSpeech_Tag::NOUN),
            7 => ::std::option::Option::Some(PartOfSpeech_Tag::NUM),
            8 => ::std::option::Option::Some(PartOfSpeech_Tag::PRON),
            9 => ::std::option::Option::Some(PartOfSpeech_Tag::PRT),
            10 => ::std::option::Option::Some(PartOfSpeech_Tag::PUNCT),
            11 => ::std::option::Option::Some(PartOfSpeech_Tag::VERB),
            12 => ::std::option::Option::Some(PartOfSpeech_Tag::X),
            13 => ::std::option::Option::Some(PartOfSpeech_Tag::AFFIX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Tag] = &[
            PartOfSpeech_Tag::UNKNOWN,
            PartOfSpeech_Tag::ADJ,
            PartOfSpeech_Tag::ADP,
            PartOfSpeech_Tag::ADV,
            PartOfSpeech_Tag::CONJ,
            PartOfSpeech_Tag::DET,
            PartOfSpeech_Tag::NOUN,
            PartOfSpeech_Tag::NUM,
            PartOfSpeech_Tag::PRON,
            PartOfSpeech_Tag::PRT,
            PartOfSpeech_Tag::PUNCT,
            PartOfSpeech_Tag::VERB,
            PartOfSpeech_Tag::X,
            PartOfSpeech_Tag::AFFIX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Tag", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Tag {
}

impl ::std::default::Default for PartOfSpeech_Tag {
    fn default() -> Self {
        PartOfSpeech_Tag::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Tag {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Aspect {
    ASPECT_UNKNOWN = 0,
    PERFECTIVE = 1,
    IMPERFECTIVE = 2,
    PROGRESSIVE = 3,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Aspect {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Aspect> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Aspect::ASPECT_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Aspect::PERFECTIVE),
            2 => ::std::option::Option::Some(PartOfSpeech_Aspect::IMPERFECTIVE),
            3 => ::std::option::Option::Some(PartOfSpeech_Aspect::PROGRESSIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Aspect] = &[
            PartOfSpeech_Aspect::ASPECT_UNKNOWN,
            PartOfSpeech_Aspect::PERFECTIVE,
            PartOfSpeech_Aspect::IMPERFECTIVE,
            PartOfSpeech_Aspect::PROGRESSIVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Aspect", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Aspect {
}

impl ::std::default::Default for PartOfSpeech_Aspect {
    fn default() -> Self {
        PartOfSpeech_Aspect::ASPECT_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Aspect {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Case {
    CASE_UNKNOWN = 0,
    ACCUSATIVE = 1,
    ADVERBIAL = 2,
    COMPLEMENTIVE = 3,
    DATIVE = 4,
    GENITIVE = 5,
    INSTRUMENTAL = 6,
    LOCATIVE = 7,
    NOMINATIVE = 8,
    OBLIQUE = 9,
    PARTITIVE = 10,
    PREPOSITIONAL = 11,
    REFLEXIVE_CASE = 12,
    RELATIVE_CASE = 13,
    VOCATIVE = 14,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Case {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Case> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Case::CASE_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Case::ACCUSATIVE),
            2 => ::std::option::Option::Some(PartOfSpeech_Case::ADVERBIAL),
            3 => ::std::option::Option::Some(PartOfSpeech_Case::COMPLEMENTIVE),
            4 => ::std::option::Option::Some(PartOfSpeech_Case::DATIVE),
            5 => ::std::option::Option::Some(PartOfSpeech_Case::GENITIVE),
            6 => ::std::option::Option::Some(PartOfSpeech_Case::INSTRUMENTAL),
            7 => ::std::option::Option::Some(PartOfSpeech_Case::LOCATIVE),
            8 => ::std::option::Option::Some(PartOfSpeech_Case::NOMINATIVE),
            9 => ::std::option::Option::Some(PartOfSpeech_Case::OBLIQUE),
            10 => ::std::option::Option::Some(PartOfSpeech_Case::PARTITIVE),
            11 => ::std::option::Option::Some(PartOfSpeech_Case::PREPOSITIONAL),
            12 => ::std::option::Option::Some(PartOfSpeech_Case::REFLEXIVE_CASE),
            13 => ::std::option::Option::Some(PartOfSpeech_Case::RELATIVE_CASE),
            14 => ::std::option::Option::Some(PartOfSpeech_Case::VOCATIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Case] = &[
            PartOfSpeech_Case::CASE_UNKNOWN,
            PartOfSpeech_Case::ACCUSATIVE,
            PartOfSpeech_Case::ADVERBIAL,
            PartOfSpeech_Case::COMPLEMENTIVE,
            PartOfSpeech_Case::DATIVE,
            PartOfSpeech_Case::GENITIVE,
            PartOfSpeech_Case::INSTRUMENTAL,
            PartOfSpeech_Case::LOCATIVE,
            PartOfSpeech_Case::NOMINATIVE,
            PartOfSpeech_Case::OBLIQUE,
            PartOfSpeech_Case::PARTITIVE,
            PartOfSpeech_Case::PREPOSITIONAL,
            PartOfSpeech_Case::REFLEXIVE_CASE,
            PartOfSpeech_Case::RELATIVE_CASE,
            PartOfSpeech_Case::VOCATIVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Case", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Case {
}

impl ::std::default::Default for PartOfSpeech_Case {
    fn default() -> Self {
        PartOfSpeech_Case::CASE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Case {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Form {
    FORM_UNKNOWN = 0,
    ADNOMIAL = 1,
    AUXILIARY = 2,
    COMPLEMENTIZER = 3,
    FINAL_ENDING = 4,
    GERUND = 5,
    REALIS = 6,
    IRREALIS = 7,
    SHORT = 8,
    LONG = 9,
    ORDER = 10,
    SPECIFIC = 11,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Form {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Form> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Form::FORM_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Form::ADNOMIAL),
            2 => ::std::option::Option::Some(PartOfSpeech_Form::AUXILIARY),
            3 => ::std::option::Option::Some(PartOfSpeech_Form::COMPLEMENTIZER),
            4 => ::std::option::Option::Some(PartOfSpeech_Form::FINAL_ENDING),
            5 => ::std::option::Option::Some(PartOfSpeech_Form::GERUND),
            6 => ::std::option::Option::Some(PartOfSpeech_Form::REALIS),
            7 => ::std::option::Option::Some(PartOfSpeech_Form::IRREALIS),
            8 => ::std::option::Option::Some(PartOfSpeech_Form::SHORT),
            9 => ::std::option::Option::Some(PartOfSpeech_Form::LONG),
            10 => ::std::option::Option::Some(PartOfSpeech_Form::ORDER),
            11 => ::std::option::Option::Some(PartOfSpeech_Form::SPECIFIC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Form] = &[
            PartOfSpeech_Form::FORM_UNKNOWN,
            PartOfSpeech_Form::ADNOMIAL,
            PartOfSpeech_Form::AUXILIARY,
            PartOfSpeech_Form::COMPLEMENTIZER,
            PartOfSpeech_Form::FINAL_ENDING,
            PartOfSpeech_Form::GERUND,
            PartOfSpeech_Form::REALIS,
            PartOfSpeech_Form::IRREALIS,
            PartOfSpeech_Form::SHORT,
            PartOfSpeech_Form::LONG,
            PartOfSpeech_Form::ORDER,
            PartOfSpeech_Form::SPECIFIC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Form", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Form {
}

impl ::std::default::Default for PartOfSpeech_Form {
    fn default() -> Self {
        PartOfSpeech_Form::FORM_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Form {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Gender {
    GENDER_UNKNOWN = 0,
    FEMININE = 1,
    MASCULINE = 2,
    NEUTER = 3,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Gender {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Gender> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Gender::GENDER_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Gender::FEMININE),
            2 => ::std::option::Option::Some(PartOfSpeech_Gender::MASCULINE),
            3 => ::std::option::Option::Some(PartOfSpeech_Gender::NEUTER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Gender] = &[
            PartOfSpeech_Gender::GENDER_UNKNOWN,
            PartOfSpeech_Gender::FEMININE,
            PartOfSpeech_Gender::MASCULINE,
            PartOfSpeech_Gender::NEUTER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Gender", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Gender {
}

impl ::std::default::Default for PartOfSpeech_Gender {
    fn default() -> Self {
        PartOfSpeech_Gender::GENDER_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Gender {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Mood {
    MOOD_UNKNOWN = 0,
    CONDITIONAL_MOOD = 1,
    IMPERATIVE = 2,
    INDICATIVE = 3,
    INTERROGATIVE = 4,
    JUSSIVE = 5,
    SUBJUNCTIVE = 6,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Mood {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Mood> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Mood::MOOD_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Mood::CONDITIONAL_MOOD),
            2 => ::std::option::Option::Some(PartOfSpeech_Mood::IMPERATIVE),
            3 => ::std::option::Option::Some(PartOfSpeech_Mood::INDICATIVE),
            4 => ::std::option::Option::Some(PartOfSpeech_Mood::INTERROGATIVE),
            5 => ::std::option::Option::Some(PartOfSpeech_Mood::JUSSIVE),
            6 => ::std::option::Option::Some(PartOfSpeech_Mood::SUBJUNCTIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Mood] = &[
            PartOfSpeech_Mood::MOOD_UNKNOWN,
            PartOfSpeech_Mood::CONDITIONAL_MOOD,
            PartOfSpeech_Mood::IMPERATIVE,
            PartOfSpeech_Mood::INDICATIVE,
            PartOfSpeech_Mood::INTERROGATIVE,
            PartOfSpeech_Mood::JUSSIVE,
            PartOfSpeech_Mood::SUBJUNCTIVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Mood", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Mood {
}

impl ::std::default::Default for PartOfSpeech_Mood {
    fn default() -> Self {
        PartOfSpeech_Mood::MOOD_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Mood {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Number {
    NUMBER_UNKNOWN = 0,
    SINGULAR = 1,
    PLURAL = 2,
    DUAL = 3,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Number {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Number> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Number::NUMBER_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Number::SINGULAR),
            2 => ::std::option::Option::Some(PartOfSpeech_Number::PLURAL),
            3 => ::std::option::Option::Some(PartOfSpeech_Number::DUAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Number] = &[
            PartOfSpeech_Number::NUMBER_UNKNOWN,
            PartOfSpeech_Number::SINGULAR,
            PartOfSpeech_Number::PLURAL,
            PartOfSpeech_Number::DUAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Number", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Number {
}

impl ::std::default::Default for PartOfSpeech_Number {
    fn default() -> Self {
        PartOfSpeech_Number::NUMBER_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Number {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Person {
    PERSON_UNKNOWN = 0,
    FIRST = 1,
    SECOND = 2,
    THIRD = 3,
    REFLEXIVE_PERSON = 4,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Person {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Person> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Person::PERSON_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Person::FIRST),
            2 => ::std::option::Option::Some(PartOfSpeech_Person::SECOND),
            3 => ::std::option::Option::Some(PartOfSpeech_Person::THIRD),
            4 => ::std::option::Option::Some(PartOfSpeech_Person::REFLEXIVE_PERSON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Person] = &[
            PartOfSpeech_Person::PERSON_UNKNOWN,
            PartOfSpeech_Person::FIRST,
            PartOfSpeech_Person::SECOND,
            PartOfSpeech_Person::THIRD,
            PartOfSpeech_Person::REFLEXIVE_PERSON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Person", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Person {
}

impl ::std::default::Default for PartOfSpeech_Person {
    fn default() -> Self {
        PartOfSpeech_Person::PERSON_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Person {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Proper {
    PROPER_UNKNOWN = 0,
    PROPER = 1,
    NOT_PROPER = 2,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Proper {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Proper> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Proper::PROPER_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Proper::PROPER),
            2 => ::std::option::Option::Some(PartOfSpeech_Proper::NOT_PROPER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Proper] = &[
            PartOfSpeech_Proper::PROPER_UNKNOWN,
            PartOfSpeech_Proper::PROPER,
            PartOfSpeech_Proper::NOT_PROPER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Proper", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Proper {
}

impl ::std::default::Default for PartOfSpeech_Proper {
    fn default() -> Self {
        PartOfSpeech_Proper::PROPER_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Proper {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Reciprocity {
    RECIPROCITY_UNKNOWN = 0,
    RECIPROCAL = 1,
    NON_RECIPROCAL = 2,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Reciprocity {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Reciprocity> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Reciprocity::RECIPROCITY_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Reciprocity::RECIPROCAL),
            2 => ::std::option::Option::Some(PartOfSpeech_Reciprocity::NON_RECIPROCAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Reciprocity] = &[
            PartOfSpeech_Reciprocity::RECIPROCITY_UNKNOWN,
            PartOfSpeech_Reciprocity::RECIPROCAL,
            PartOfSpeech_Reciprocity::NON_RECIPROCAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Reciprocity", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Reciprocity {
}

impl ::std::default::Default for PartOfSpeech_Reciprocity {
    fn default() -> Self {
        PartOfSpeech_Reciprocity::RECIPROCITY_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Reciprocity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Tense {
    TENSE_UNKNOWN = 0,
    CONDITIONAL_TENSE = 1,
    FUTURE = 2,
    PAST = 3,
    PRESENT = 4,
    IMPERFECT = 5,
    PLUPERFECT = 6,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Tense {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Tense> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Tense::TENSE_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Tense::CONDITIONAL_TENSE),
            2 => ::std::option::Option::Some(PartOfSpeech_Tense::FUTURE),
            3 => ::std::option::Option::Some(PartOfSpeech_Tense::PAST),
            4 => ::std::option::Option::Some(PartOfSpeech_Tense::PRESENT),
            5 => ::std::option::Option::Some(PartOfSpeech_Tense::IMPERFECT),
            6 => ::std::option::Option::Some(PartOfSpeech_Tense::PLUPERFECT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Tense] = &[
            PartOfSpeech_Tense::TENSE_UNKNOWN,
            PartOfSpeech_Tense::CONDITIONAL_TENSE,
            PartOfSpeech_Tense::FUTURE,
            PartOfSpeech_Tense::PAST,
            PartOfSpeech_Tense::PRESENT,
            PartOfSpeech_Tense::IMPERFECT,
            PartOfSpeech_Tense::PLUPERFECT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Tense", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Tense {
}

impl ::std::default::Default for PartOfSpeech_Tense {
    fn default() -> Self {
        PartOfSpeech_Tense::TENSE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Tense {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PartOfSpeech_Voice {
    VOICE_UNKNOWN = 0,
    ACTIVE = 1,
    CAUSATIVE = 2,
    PASSIVE = 3,
}

impl ::protobuf::ProtobufEnum for PartOfSpeech_Voice {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartOfSpeech_Voice> {
        match value {
            0 => ::std::option::Option::Some(PartOfSpeech_Voice::VOICE_UNKNOWN),
            1 => ::std::option::Option::Some(PartOfSpeech_Voice::ACTIVE),
            2 => ::std::option::Option::Some(PartOfSpeech_Voice::CAUSATIVE),
            3 => ::std::option::Option::Some(PartOfSpeech_Voice::PASSIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartOfSpeech_Voice] = &[
            PartOfSpeech_Voice::VOICE_UNKNOWN,
            PartOfSpeech_Voice::ACTIVE,
            PartOfSpeech_Voice::CAUSATIVE,
            PartOfSpeech_Voice::PASSIVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PartOfSpeech_Voice", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PartOfSpeech_Voice {
}

impl ::std::default::Default for PartOfSpeech_Voice {
    fn default() -> Self {
        PartOfSpeech_Voice::VOICE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for PartOfSpeech_Voice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DependencyEdge {
    // message fields
    pub head_token_index: i32,
    pub label: DependencyEdge_Label,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DependencyEdge {
    fn default() -> &'a DependencyEdge {
        <DependencyEdge as ::protobuf::Message>::default_instance()
    }
}

impl DependencyEdge {
    pub fn new() -> DependencyEdge {
        ::std::default::Default::default()
    }

    // int32 head_token_index = 1;


    pub fn get_head_token_index(&self) -> i32 {
        self.head_token_index
    }
    pub fn clear_head_token_index(&mut self) {
        self.head_token_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_head_token_index(&mut self, v: i32) {
        self.head_token_index = v;
    }

    // .google.cloud.language.v1.DependencyEdge.Label label = 2;


    pub fn get_label(&self) -> DependencyEdge_Label {
        self.label
    }
    pub fn clear_label(&mut self) {
        self.label = DependencyEdge_Label::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: DependencyEdge_Label) {
        self.label = v;
    }
}

impl ::protobuf::Message for DependencyEdge {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.head_token_index = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.label, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.head_token_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.head_token_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != DependencyEdge_Label::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.head_token_index != 0 {
            os.write_int32(1, self.head_token_index)?;
        }
        if self.label != DependencyEdge_Label::UNKNOWN {
            os.write_enum(2, self.label.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DependencyEdge {
        DependencyEdge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "head_token_index",
                    |m: &DependencyEdge| { &m.head_token_index },
                    |m: &mut DependencyEdge| { &mut m.head_token_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DependencyEdge_Label>>(
                    "label",
                    |m: &DependencyEdge| { &m.label },
                    |m: &mut DependencyEdge| { &mut m.label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DependencyEdge>(
                    "DependencyEdge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DependencyEdge {
        static mut instance: ::protobuf::lazy::Lazy<DependencyEdge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DependencyEdge,
        };
        unsafe {
            instance.get(DependencyEdge::new)
        }
    }
}

impl ::protobuf::Clear for DependencyEdge {
    fn clear(&mut self) {
        self.head_token_index = 0;
        self.label = DependencyEdge_Label::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DependencyEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DependencyEdge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DependencyEdge_Label {
    UNKNOWN = 0,
    ABBREV = 1,
    ACOMP = 2,
    ADVCL = 3,
    ADVMOD = 4,
    AMOD = 5,
    APPOS = 6,
    ATTR = 7,
    AUX = 8,
    AUXPASS = 9,
    CC = 10,
    CCOMP = 11,
    CONJ = 12,
    CSUBJ = 13,
    CSUBJPASS = 14,
    DEP = 15,
    DET = 16,
    DISCOURSE = 17,
    DOBJ = 18,
    EXPL = 19,
    GOESWITH = 20,
    IOBJ = 21,
    MARK = 22,
    MWE = 23,
    MWV = 24,
    NEG = 25,
    NN = 26,
    NPADVMOD = 27,
    NSUBJ = 28,
    NSUBJPASS = 29,
    NUM = 30,
    NUMBER = 31,
    P = 32,
    PARATAXIS = 33,
    PARTMOD = 34,
    PCOMP = 35,
    POBJ = 36,
    POSS = 37,
    POSTNEG = 38,
    PRECOMP = 39,
    PRECONJ = 40,
    PREDET = 41,
    PREF = 42,
    PREP = 43,
    PRONL = 44,
    PRT = 45,
    PS = 46,
    QUANTMOD = 47,
    RCMOD = 48,
    RCMODREL = 49,
    RDROP = 50,
    REF = 51,
    REMNANT = 52,
    REPARANDUM = 53,
    ROOT = 54,
    SNUM = 55,
    SUFF = 56,
    TMOD = 57,
    TOPIC = 58,
    VMOD = 59,
    VOCATIVE = 60,
    XCOMP = 61,
    SUFFIX = 62,
    TITLE = 63,
    ADVPHMOD = 64,
    AUXCAUS = 65,
    AUXVV = 66,
    DTMOD = 67,
    FOREIGN = 68,
    KW = 69,
    LIST = 70,
    NOMC = 71,
    NOMCSUBJ = 72,
    NOMCSUBJPASS = 73,
    NUMC = 74,
    COP = 75,
    DISLOCATED = 76,
    ASP = 77,
    GMOD = 78,
    GOBJ = 79,
    INFMOD = 80,
    MES = 81,
    NCOMP = 82,
}

impl ::protobuf::ProtobufEnum for DependencyEdge_Label {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DependencyEdge_Label> {
        match value {
            0 => ::std::option::Option::Some(DependencyEdge_Label::UNKNOWN),
            1 => ::std::option::Option::Some(DependencyEdge_Label::ABBREV),
            2 => ::std::option::Option::Some(DependencyEdge_Label::ACOMP),
            3 => ::std::option::Option::Some(DependencyEdge_Label::ADVCL),
            4 => ::std::option::Option::Some(DependencyEdge_Label::ADVMOD),
            5 => ::std::option::Option::Some(DependencyEdge_Label::AMOD),
            6 => ::std::option::Option::Some(DependencyEdge_Label::APPOS),
            7 => ::std::option::Option::Some(DependencyEdge_Label::ATTR),
            8 => ::std::option::Option::Some(DependencyEdge_Label::AUX),
            9 => ::std::option::Option::Some(DependencyEdge_Label::AUXPASS),
            10 => ::std::option::Option::Some(DependencyEdge_Label::CC),
            11 => ::std::option::Option::Some(DependencyEdge_Label::CCOMP),
            12 => ::std::option::Option::Some(DependencyEdge_Label::CONJ),
            13 => ::std::option::Option::Some(DependencyEdge_Label::CSUBJ),
            14 => ::std::option::Option::Some(DependencyEdge_Label::CSUBJPASS),
            15 => ::std::option::Option::Some(DependencyEdge_Label::DEP),
            16 => ::std::option::Option::Some(DependencyEdge_Label::DET),
            17 => ::std::option::Option::Some(DependencyEdge_Label::DISCOURSE),
            18 => ::std::option::Option::Some(DependencyEdge_Label::DOBJ),
            19 => ::std::option::Option::Some(DependencyEdge_Label::EXPL),
            20 => ::std::option::Option::Some(DependencyEdge_Label::GOESWITH),
            21 => ::std::option::Option::Some(DependencyEdge_Label::IOBJ),
            22 => ::std::option::Option::Some(DependencyEdge_Label::MARK),
            23 => ::std::option::Option::Some(DependencyEdge_Label::MWE),
            24 => ::std::option::Option::Some(DependencyEdge_Label::MWV),
            25 => ::std::option::Option::Some(DependencyEdge_Label::NEG),
            26 => ::std::option::Option::Some(DependencyEdge_Label::NN),
            27 => ::std::option::Option::Some(DependencyEdge_Label::NPADVMOD),
            28 => ::std::option::Option::Some(DependencyEdge_Label::NSUBJ),
            29 => ::std::option::Option::Some(DependencyEdge_Label::NSUBJPASS),
            30 => ::std::option::Option::Some(DependencyEdge_Label::NUM),
            31 => ::std::option::Option::Some(DependencyEdge_Label::NUMBER),
            32 => ::std::option::Option::Some(DependencyEdge_Label::P),
            33 => ::std::option::Option::Some(DependencyEdge_Label::PARATAXIS),
            34 => ::std::option::Option::Some(DependencyEdge_Label::PARTMOD),
            35 => ::std::option::Option::Some(DependencyEdge_Label::PCOMP),
            36 => ::std::option::Option::Some(DependencyEdge_Label::POBJ),
            37 => ::std::option::Option::Some(DependencyEdge_Label::POSS),
            38 => ::std::option::Option::Some(DependencyEdge_Label::POSTNEG),
            39 => ::std::option::Option::Some(DependencyEdge_Label::PRECOMP),
            40 => ::std::option::Option::Some(DependencyEdge_Label::PRECONJ),
            41 => ::std::option::Option::Some(DependencyEdge_Label::PREDET),
            42 => ::std::option::Option::Some(DependencyEdge_Label::PREF),
            43 => ::std::option::Option::Some(DependencyEdge_Label::PREP),
            44 => ::std::option::Option::Some(DependencyEdge_Label::PRONL),
            45 => ::std::option::Option::Some(DependencyEdge_Label::PRT),
            46 => ::std::option::Option::Some(DependencyEdge_Label::PS),
            47 => ::std::option::Option::Some(DependencyEdge_Label::QUANTMOD),
            48 => ::std::option::Option::Some(DependencyEdge_Label::RCMOD),
            49 => ::std::option::Option::Some(DependencyEdge_Label::RCMODREL),
            50 => ::std::option::Option::Some(DependencyEdge_Label::RDROP),
            51 => ::std::option::Option::Some(DependencyEdge_Label::REF),
            52 => ::std::option::Option::Some(DependencyEdge_Label::REMNANT),
            53 => ::std::option::Option::Some(DependencyEdge_Label::REPARANDUM),
            54 => ::std::option::Option::Some(DependencyEdge_Label::ROOT),
            55 => ::std::option::Option::Some(DependencyEdge_Label::SNUM),
            56 => ::std::option::Option::Some(DependencyEdge_Label::SUFF),
            57 => ::std::option::Option::Some(DependencyEdge_Label::TMOD),
            58 => ::std::option::Option::Some(DependencyEdge_Label::TOPIC),
            59 => ::std::option::Option::Some(DependencyEdge_Label::VMOD),
            60 => ::std::option::Option::Some(DependencyEdge_Label::VOCATIVE),
            61 => ::std::option::Option::Some(DependencyEdge_Label::XCOMP),
            62 => ::std::option::Option::Some(DependencyEdge_Label::SUFFIX),
            63 => ::std::option::Option::Some(DependencyEdge_Label::TITLE),
            64 => ::std::option::Option::Some(DependencyEdge_Label::ADVPHMOD),
            65 => ::std::option::Option::Some(DependencyEdge_Label::AUXCAUS),
            66 => ::std::option::Option::Some(DependencyEdge_Label::AUXVV),
            67 => ::std::option::Option::Some(DependencyEdge_Label::DTMOD),
            68 => ::std::option::Option::Some(DependencyEdge_Label::FOREIGN),
            69 => ::std::option::Option::Some(DependencyEdge_Label::KW),
            70 => ::std::option::Option::Some(DependencyEdge_Label::LIST),
            71 => ::std::option::Option::Some(DependencyEdge_Label::NOMC),
            72 => ::std::option::Option::Some(DependencyEdge_Label::NOMCSUBJ),
            73 => ::std::option::Option::Some(DependencyEdge_Label::NOMCSUBJPASS),
            74 => ::std::option::Option::Some(DependencyEdge_Label::NUMC),
            75 => ::std::option::Option::Some(DependencyEdge_Label::COP),
            76 => ::std::option::Option::Some(DependencyEdge_Label::DISLOCATED),
            77 => ::std::option::Option::Some(DependencyEdge_Label::ASP),
            78 => ::std::option::Option::Some(DependencyEdge_Label::GMOD),
            79 => ::std::option::Option::Some(DependencyEdge_Label::GOBJ),
            80 => ::std::option::Option::Some(DependencyEdge_Label::INFMOD),
            81 => ::std::option::Option::Some(DependencyEdge_Label::MES),
            82 => ::std::option::Option::Some(DependencyEdge_Label::NCOMP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DependencyEdge_Label] = &[
            DependencyEdge_Label::UNKNOWN,
            DependencyEdge_Label::ABBREV,
            DependencyEdge_Label::ACOMP,
            DependencyEdge_Label::ADVCL,
            DependencyEdge_Label::ADVMOD,
            DependencyEdge_Label::AMOD,
            DependencyEdge_Label::APPOS,
            DependencyEdge_Label::ATTR,
            DependencyEdge_Label::AUX,
            DependencyEdge_Label::AUXPASS,
            DependencyEdge_Label::CC,
            DependencyEdge_Label::CCOMP,
            DependencyEdge_Label::CONJ,
            DependencyEdge_Label::CSUBJ,
            DependencyEdge_Label::CSUBJPASS,
            DependencyEdge_Label::DEP,
            DependencyEdge_Label::DET,
            DependencyEdge_Label::DISCOURSE,
            DependencyEdge_Label::DOBJ,
            DependencyEdge_Label::EXPL,
            DependencyEdge_Label::GOESWITH,
            DependencyEdge_Label::IOBJ,
            DependencyEdge_Label::MARK,
            DependencyEdge_Label::MWE,
            DependencyEdge_Label::MWV,
            DependencyEdge_Label::NEG,
            DependencyEdge_Label::NN,
            DependencyEdge_Label::NPADVMOD,
            DependencyEdge_Label::NSUBJ,
            DependencyEdge_Label::NSUBJPASS,
            DependencyEdge_Label::NUM,
            DependencyEdge_Label::NUMBER,
            DependencyEdge_Label::P,
            DependencyEdge_Label::PARATAXIS,
            DependencyEdge_Label::PARTMOD,
            DependencyEdge_Label::PCOMP,
            DependencyEdge_Label::POBJ,
            DependencyEdge_Label::POSS,
            DependencyEdge_Label::POSTNEG,
            DependencyEdge_Label::PRECOMP,
            DependencyEdge_Label::PRECONJ,
            DependencyEdge_Label::PREDET,
            DependencyEdge_Label::PREF,
            DependencyEdge_Label::PREP,
            DependencyEdge_Label::PRONL,
            DependencyEdge_Label::PRT,
            DependencyEdge_Label::PS,
            DependencyEdge_Label::QUANTMOD,
            DependencyEdge_Label::RCMOD,
            DependencyEdge_Label::RCMODREL,
            DependencyEdge_Label::RDROP,
            DependencyEdge_Label::REF,
            DependencyEdge_Label::REMNANT,
            DependencyEdge_Label::REPARANDUM,
            DependencyEdge_Label::ROOT,
            DependencyEdge_Label::SNUM,
            DependencyEdge_Label::SUFF,
            DependencyEdge_Label::TMOD,
            DependencyEdge_Label::TOPIC,
            DependencyEdge_Label::VMOD,
            DependencyEdge_Label::VOCATIVE,
            DependencyEdge_Label::XCOMP,
            DependencyEdge_Label::SUFFIX,
            DependencyEdge_Label::TITLE,
            DependencyEdge_Label::ADVPHMOD,
            DependencyEdge_Label::AUXCAUS,
            DependencyEdge_Label::AUXVV,
            DependencyEdge_Label::DTMOD,
            DependencyEdge_Label::FOREIGN,
            DependencyEdge_Label::KW,
            DependencyEdge_Label::LIST,
            DependencyEdge_Label::NOMC,
            DependencyEdge_Label::NOMCSUBJ,
            DependencyEdge_Label::NOMCSUBJPASS,
            DependencyEdge_Label::NUMC,
            DependencyEdge_Label::COP,
            DependencyEdge_Label::DISLOCATED,
            DependencyEdge_Label::ASP,
            DependencyEdge_Label::GMOD,
            DependencyEdge_Label::GOBJ,
            DependencyEdge_Label::INFMOD,
            DependencyEdge_Label::MES,
            DependencyEdge_Label::NCOMP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DependencyEdge_Label", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DependencyEdge_Label {
}

impl ::std::default::Default for DependencyEdge_Label {
    fn default() -> Self {
        DependencyEdge_Label::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for DependencyEdge_Label {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntityMention {
    // message fields
    pub text: ::protobuf::SingularPtrField<TextSpan>,
    pub field_type: EntityMention_Type,
    pub sentiment: ::protobuf::SingularPtrField<Sentiment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EntityMention {
    fn default() -> &'a EntityMention {
        <EntityMention as ::protobuf::Message>::default_instance()
    }
}

impl EntityMention {
    pub fn new() -> EntityMention {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.TextSpan text = 1;


    pub fn get_text(&self) -> &TextSpan {
        self.text.as_ref().unwrap_or_else(|| TextSpan::default_instance())
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: TextSpan) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut TextSpan {
        if self.text.is_none() {
            self.text.set_default();
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> TextSpan {
        self.text.take().unwrap_or_else(|| TextSpan::new())
    }

    // .google.cloud.language.v1.EntityMention.Type type = 2;


    pub fn get_field_type(&self) -> EntityMention_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = EntityMention_Type::TYPE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: EntityMention_Type) {
        self.field_type = v;
    }

    // .google.cloud.language.v1.Sentiment sentiment = 3;


    pub fn get_sentiment(&self) -> &Sentiment {
        self.sentiment.as_ref().unwrap_or_else(|| Sentiment::default_instance())
    }
    pub fn clear_sentiment(&mut self) {
        self.sentiment.clear();
    }

    pub fn has_sentiment(&self) -> bool {
        self.sentiment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sentiment(&mut self, v: Sentiment) {
        self.sentiment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sentiment(&mut self) -> &mut Sentiment {
        if self.sentiment.is_none() {
            self.sentiment.set_default();
        }
        self.sentiment.as_mut().unwrap()
    }

    // Take field
    pub fn take_sentiment(&mut self) -> Sentiment {
        self.sentiment.take().unwrap_or_else(|| Sentiment::new())
    }
}

impl ::protobuf::Message for EntityMention {
    fn is_initialized(&self) -> bool {
        for v in &self.text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sentiment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sentiment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.field_type != EntityMention_Type::TYPE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if let Some(ref v) = self.sentiment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.text.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.field_type != EntityMention_Type::TYPE_UNKNOWN {
            os.write_enum(2, self.field_type.value())?;
        }
        if let Some(ref v) = self.sentiment.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntityMention {
        EntityMention::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TextSpan>>(
                    "text",
                    |m: &EntityMention| { &m.text },
                    |m: &mut EntityMention| { &mut m.text },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EntityMention_Type>>(
                    "type",
                    |m: &EntityMention| { &m.field_type },
                    |m: &mut EntityMention| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sentiment>>(
                    "sentiment",
                    |m: &EntityMention| { &m.sentiment },
                    |m: &mut EntityMention| { &mut m.sentiment },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EntityMention>(
                    "EntityMention",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntityMention {
        static mut instance: ::protobuf::lazy::Lazy<EntityMention> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntityMention,
        };
        unsafe {
            instance.get(EntityMention::new)
        }
    }
}

impl ::protobuf::Clear for EntityMention {
    fn clear(&mut self) {
        self.text.clear();
        self.field_type = EntityMention_Type::TYPE_UNKNOWN;
        self.sentiment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntityMention {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityMention {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EntityMention_Type {
    TYPE_UNKNOWN = 0,
    PROPER = 1,
    COMMON = 2,
}

impl ::protobuf::ProtobufEnum for EntityMention_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EntityMention_Type> {
        match value {
            0 => ::std::option::Option::Some(EntityMention_Type::TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(EntityMention_Type::PROPER),
            2 => ::std::option::Option::Some(EntityMention_Type::COMMON),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EntityMention_Type] = &[
            EntityMention_Type::TYPE_UNKNOWN,
            EntityMention_Type::PROPER,
            EntityMention_Type::COMMON,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EntityMention_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EntityMention_Type {
}

impl ::std::default::Default for EntityMention_Type {
    fn default() -> Self {
        EntityMention_Type::TYPE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for EntityMention_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TextSpan {
    // message fields
    pub content: ::std::string::String,
    pub begin_offset: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextSpan {
    fn default() -> &'a TextSpan {
        <TextSpan as ::protobuf::Message>::default_instance()
    }
}

impl TextSpan {
    pub fn new() -> TextSpan {
        ::std::default::Default::default()
    }

    // string content = 1;


    pub fn get_content(&self) -> &str {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    // int32 begin_offset = 2;


    pub fn get_begin_offset(&self) -> i32 {
        self.begin_offset
    }
    pub fn clear_begin_offset(&mut self) {
        self.begin_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_begin_offset(&mut self, v: i32) {
        self.begin_offset = v;
    }
}

impl ::protobuf::Message for TextSpan {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.begin_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.content);
        }
        if self.begin_offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.begin_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_string(1, &self.content)?;
        }
        if self.begin_offset != 0 {
            os.write_int32(2, self.begin_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TextSpan {
        TextSpan::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "content",
                    |m: &TextSpan| { &m.content },
                    |m: &mut TextSpan| { &mut m.content },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "begin_offset",
                    |m: &TextSpan| { &m.begin_offset },
                    |m: &mut TextSpan| { &mut m.begin_offset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TextSpan>(
                    "TextSpan",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TextSpan {
        static mut instance: ::protobuf::lazy::Lazy<TextSpan> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TextSpan,
        };
        unsafe {
            instance.get(TextSpan::new)
        }
    }
}

impl ::protobuf::Clear for TextSpan {
    fn clear(&mut self) {
        self.content.clear();
        self.begin_offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextSpan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextSpan {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClassificationCategory {
    // message fields
    pub name: ::std::string::String,
    pub confidence: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClassificationCategory {
    fn default() -> &'a ClassificationCategory {
        <ClassificationCategory as ::protobuf::Message>::default_instance()
    }
}

impl ClassificationCategory {
    pub fn new() -> ClassificationCategory {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // float confidence = 2;


    pub fn get_confidence(&self) -> f32 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f32) {
        self.confidence = v;
    }
}

impl ::protobuf::Message for ClassificationCategory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.confidence = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.confidence != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.confidence != 0. {
            os.write_float(2, self.confidence)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClassificationCategory {
        ClassificationCategory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &ClassificationCategory| { &m.name },
                    |m: &mut ClassificationCategory| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "confidence",
                    |m: &ClassificationCategory| { &m.confidence },
                    |m: &mut ClassificationCategory| { &mut m.confidence },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClassificationCategory>(
                    "ClassificationCategory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClassificationCategory {
        static mut instance: ::protobuf::lazy::Lazy<ClassificationCategory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClassificationCategory,
        };
        unsafe {
            instance.get(ClassificationCategory::new)
        }
    }
}

impl ::protobuf::Clear for ClassificationCategory {
    fn clear(&mut self) {
        self.name.clear();
        self.confidence = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClassificationCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClassificationCategory {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeSentimentRequest {
    // message fields
    pub document: ::protobuf::SingularPtrField<Document>,
    pub encoding_type: EncodingType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeSentimentRequest {
    fn default() -> &'a AnalyzeSentimentRequest {
        <AnalyzeSentimentRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeSentimentRequest {
    pub fn new() -> AnalyzeSentimentRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.Document document = 1;


    pub fn get_document(&self) -> &Document {
        self.document.as_ref().unwrap_or_else(|| Document::default_instance())
    }
    pub fn clear_document(&mut self) {
        self.document.clear();
    }

    pub fn has_document(&self) -> bool {
        self.document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document(&mut self, v: Document) {
        self.document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document(&mut self) -> &mut Document {
        if self.document.is_none() {
            self.document.set_default();
        }
        self.document.as_mut().unwrap()
    }

    // Take field
    pub fn take_document(&mut self) -> Document {
        self.document.take().unwrap_or_else(|| Document::new())
    }

    // .google.cloud.language.v1.EncodingType encoding_type = 2;


    pub fn get_encoding_type(&self) -> EncodingType {
        self.encoding_type
    }
    pub fn clear_encoding_type(&mut self) {
        self.encoding_type = EncodingType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_encoding_type(&mut self, v: EncodingType) {
        self.encoding_type = v;
    }
}

impl ::protobuf::Message for AnalyzeSentimentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.encoding_type != EncodingType::NONE {
            my_size += ::protobuf::rt::enum_size(2, self.encoding_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.document.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.encoding_type != EncodingType::NONE {
            os.write_enum(2, self.encoding_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeSentimentRequest {
        AnalyzeSentimentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                    "document",
                    |m: &AnalyzeSentimentRequest| { &m.document },
                    |m: &mut AnalyzeSentimentRequest| { &mut m.document },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncodingType>>(
                    "encoding_type",
                    |m: &AnalyzeSentimentRequest| { &m.encoding_type },
                    |m: &mut AnalyzeSentimentRequest| { &mut m.encoding_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnalyzeSentimentRequest>(
                    "AnalyzeSentimentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnalyzeSentimentRequest {
        static mut instance: ::protobuf::lazy::Lazy<AnalyzeSentimentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnalyzeSentimentRequest,
        };
        unsafe {
            instance.get(AnalyzeSentimentRequest::new)
        }
    }
}

impl ::protobuf::Clear for AnalyzeSentimentRequest {
    fn clear(&mut self) {
        self.document.clear();
        self.encoding_type = EncodingType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeSentimentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeSentimentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeSentimentResponse {
    // message fields
    pub document_sentiment: ::protobuf::SingularPtrField<Sentiment>,
    pub language: ::std::string::String,
    pub sentences: ::protobuf::RepeatedField<Sentence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeSentimentResponse {
    fn default() -> &'a AnalyzeSentimentResponse {
        <AnalyzeSentimentResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeSentimentResponse {
    pub fn new() -> AnalyzeSentimentResponse {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.Sentiment document_sentiment = 1;


    pub fn get_document_sentiment(&self) -> &Sentiment {
        self.document_sentiment.as_ref().unwrap_or_else(|| Sentiment::default_instance())
    }
    pub fn clear_document_sentiment(&mut self) {
        self.document_sentiment.clear();
    }

    pub fn has_document_sentiment(&self) -> bool {
        self.document_sentiment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document_sentiment(&mut self, v: Sentiment) {
        self.document_sentiment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document_sentiment(&mut self) -> &mut Sentiment {
        if self.document_sentiment.is_none() {
            self.document_sentiment.set_default();
        }
        self.document_sentiment.as_mut().unwrap()
    }

    // Take field
    pub fn take_document_sentiment(&mut self) -> Sentiment {
        self.document_sentiment.take().unwrap_or_else(|| Sentiment::new())
    }

    // string language = 2;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }

    // repeated .google.cloud.language.v1.Sentence sentences = 3;


    pub fn get_sentences(&self) -> &[Sentence] {
        &self.sentences
    }
    pub fn clear_sentences(&mut self) {
        self.sentences.clear();
    }

    // Param is passed by value, moved
    pub fn set_sentences(&mut self, v: ::protobuf::RepeatedField<Sentence>) {
        self.sentences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sentences(&mut self) -> &mut ::protobuf::RepeatedField<Sentence> {
        &mut self.sentences
    }

    // Take field
    pub fn take_sentences(&mut self) -> ::protobuf::RepeatedField<Sentence> {
        ::std::mem::replace(&mut self.sentences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnalyzeSentimentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.document_sentiment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sentences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document_sentiment)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sentences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.document_sentiment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.language);
        }
        for value in &self.sentences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.document_sentiment.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.language.is_empty() {
            os.write_string(2, &self.language)?;
        }
        for v in &self.sentences {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeSentimentResponse {
        AnalyzeSentimentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sentiment>>(
                    "document_sentiment",
                    |m: &AnalyzeSentimentResponse| { &m.document_sentiment },
                    |m: &mut AnalyzeSentimentResponse| { &mut m.document_sentiment },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &AnalyzeSentimentResponse| { &m.language },
                    |m: &mut AnalyzeSentimentResponse| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sentence>>(
                    "sentences",
                    |m: &AnalyzeSentimentResponse| { &m.sentences },
                    |m: &mut AnalyzeSentimentResponse| { &mut m.sentences },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnalyzeSentimentResponse>(
                    "AnalyzeSentimentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnalyzeSentimentResponse {
        static mut instance: ::protobuf::lazy::Lazy<AnalyzeSentimentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnalyzeSentimentResponse,
        };
        unsafe {
            instance.get(AnalyzeSentimentResponse::new)
        }
    }
}

impl ::protobuf::Clear for AnalyzeSentimentResponse {
    fn clear(&mut self) {
        self.document_sentiment.clear();
        self.language.clear();
        self.sentences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeSentimentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeSentimentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeEntitySentimentRequest {
    // message fields
    pub document: ::protobuf::SingularPtrField<Document>,
    pub encoding_type: EncodingType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeEntitySentimentRequest {
    fn default() -> &'a AnalyzeEntitySentimentRequest {
        <AnalyzeEntitySentimentRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeEntitySentimentRequest {
    pub fn new() -> AnalyzeEntitySentimentRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.Document document = 1;


    pub fn get_document(&self) -> &Document {
        self.document.as_ref().unwrap_or_else(|| Document::default_instance())
    }
    pub fn clear_document(&mut self) {
        self.document.clear();
    }

    pub fn has_document(&self) -> bool {
        self.document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document(&mut self, v: Document) {
        self.document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document(&mut self) -> &mut Document {
        if self.document.is_none() {
            self.document.set_default();
        }
        self.document.as_mut().unwrap()
    }

    // Take field
    pub fn take_document(&mut self) -> Document {
        self.document.take().unwrap_or_else(|| Document::new())
    }

    // .google.cloud.language.v1.EncodingType encoding_type = 2;


    pub fn get_encoding_type(&self) -> EncodingType {
        self.encoding_type
    }
    pub fn clear_encoding_type(&mut self) {
        self.encoding_type = EncodingType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_encoding_type(&mut self, v: EncodingType) {
        self.encoding_type = v;
    }
}

impl ::protobuf::Message for AnalyzeEntitySentimentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.encoding_type != EncodingType::NONE {
            my_size += ::protobuf::rt::enum_size(2, self.encoding_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.document.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.encoding_type != EncodingType::NONE {
            os.write_enum(2, self.encoding_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeEntitySentimentRequest {
        AnalyzeEntitySentimentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                    "document",
                    |m: &AnalyzeEntitySentimentRequest| { &m.document },
                    |m: &mut AnalyzeEntitySentimentRequest| { &mut m.document },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncodingType>>(
                    "encoding_type",
                    |m: &AnalyzeEntitySentimentRequest| { &m.encoding_type },
                    |m: &mut AnalyzeEntitySentimentRequest| { &mut m.encoding_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnalyzeEntitySentimentRequest>(
                    "AnalyzeEntitySentimentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnalyzeEntitySentimentRequest {
        static mut instance: ::protobuf::lazy::Lazy<AnalyzeEntitySentimentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnalyzeEntitySentimentRequest,
        };
        unsafe {
            instance.get(AnalyzeEntitySentimentRequest::new)
        }
    }
}

impl ::protobuf::Clear for AnalyzeEntitySentimentRequest {
    fn clear(&mut self) {
        self.document.clear();
        self.encoding_type = EncodingType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeEntitySentimentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeEntitySentimentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeEntitySentimentResponse {
    // message fields
    pub entities: ::protobuf::RepeatedField<Entity>,
    pub language: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeEntitySentimentResponse {
    fn default() -> &'a AnalyzeEntitySentimentResponse {
        <AnalyzeEntitySentimentResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeEntitySentimentResponse {
    pub fn new() -> AnalyzeEntitySentimentResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.language.v1.Entity entities = 1;


    pub fn get_entities(&self) -> &[Entity] {
        &self.entities
    }
    pub fn clear_entities(&mut self) {
        self.entities.clear();
    }

    // Param is passed by value, moved
    pub fn set_entities(&mut self, v: ::protobuf::RepeatedField<Entity>) {
        self.entities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entities(&mut self) -> &mut ::protobuf::RepeatedField<Entity> {
        &mut self.entities
    }

    // Take field
    pub fn take_entities(&mut self) -> ::protobuf::RepeatedField<Entity> {
        ::std::mem::replace(&mut self.entities, ::protobuf::RepeatedField::new())
    }

    // string language = 2;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeEntitySentimentResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entities)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.language.is_empty() {
            os.write_string(2, &self.language)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeEntitySentimentResponse {
        AnalyzeEntitySentimentResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entity>>(
                    "entities",
                    |m: &AnalyzeEntitySentimentResponse| { &m.entities },
                    |m: &mut AnalyzeEntitySentimentResponse| { &mut m.entities },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &AnalyzeEntitySentimentResponse| { &m.language },
                    |m: &mut AnalyzeEntitySentimentResponse| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnalyzeEntitySentimentResponse>(
                    "AnalyzeEntitySentimentResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnalyzeEntitySentimentResponse {
        static mut instance: ::protobuf::lazy::Lazy<AnalyzeEntitySentimentResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnalyzeEntitySentimentResponse,
        };
        unsafe {
            instance.get(AnalyzeEntitySentimentResponse::new)
        }
    }
}

impl ::protobuf::Clear for AnalyzeEntitySentimentResponse {
    fn clear(&mut self) {
        self.entities.clear();
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeEntitySentimentResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeEntitySentimentResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeEntitiesRequest {
    // message fields
    pub document: ::protobuf::SingularPtrField<Document>,
    pub encoding_type: EncodingType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeEntitiesRequest {
    fn default() -> &'a AnalyzeEntitiesRequest {
        <AnalyzeEntitiesRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeEntitiesRequest {
    pub fn new() -> AnalyzeEntitiesRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.Document document = 1;


    pub fn get_document(&self) -> &Document {
        self.document.as_ref().unwrap_or_else(|| Document::default_instance())
    }
    pub fn clear_document(&mut self) {
        self.document.clear();
    }

    pub fn has_document(&self) -> bool {
        self.document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document(&mut self, v: Document) {
        self.document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document(&mut self) -> &mut Document {
        if self.document.is_none() {
            self.document.set_default();
        }
        self.document.as_mut().unwrap()
    }

    // Take field
    pub fn take_document(&mut self) -> Document {
        self.document.take().unwrap_or_else(|| Document::new())
    }

    // .google.cloud.language.v1.EncodingType encoding_type = 2;


    pub fn get_encoding_type(&self) -> EncodingType {
        self.encoding_type
    }
    pub fn clear_encoding_type(&mut self) {
        self.encoding_type = EncodingType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_encoding_type(&mut self, v: EncodingType) {
        self.encoding_type = v;
    }
}

impl ::protobuf::Message for AnalyzeEntitiesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.encoding_type != EncodingType::NONE {
            my_size += ::protobuf::rt::enum_size(2, self.encoding_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.document.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.encoding_type != EncodingType::NONE {
            os.write_enum(2, self.encoding_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeEntitiesRequest {
        AnalyzeEntitiesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                    "document",
                    |m: &AnalyzeEntitiesRequest| { &m.document },
                    |m: &mut AnalyzeEntitiesRequest| { &mut m.document },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncodingType>>(
                    "encoding_type",
                    |m: &AnalyzeEntitiesRequest| { &m.encoding_type },
                    |m: &mut AnalyzeEntitiesRequest| { &mut m.encoding_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnalyzeEntitiesRequest>(
                    "AnalyzeEntitiesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnalyzeEntitiesRequest {
        static mut instance: ::protobuf::lazy::Lazy<AnalyzeEntitiesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnalyzeEntitiesRequest,
        };
        unsafe {
            instance.get(AnalyzeEntitiesRequest::new)
        }
    }
}

impl ::protobuf::Clear for AnalyzeEntitiesRequest {
    fn clear(&mut self) {
        self.document.clear();
        self.encoding_type = EncodingType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeEntitiesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeEntitiesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeEntitiesResponse {
    // message fields
    pub entities: ::protobuf::RepeatedField<Entity>,
    pub language: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeEntitiesResponse {
    fn default() -> &'a AnalyzeEntitiesResponse {
        <AnalyzeEntitiesResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeEntitiesResponse {
    pub fn new() -> AnalyzeEntitiesResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.language.v1.Entity entities = 1;


    pub fn get_entities(&self) -> &[Entity] {
        &self.entities
    }
    pub fn clear_entities(&mut self) {
        self.entities.clear();
    }

    // Param is passed by value, moved
    pub fn set_entities(&mut self, v: ::protobuf::RepeatedField<Entity>) {
        self.entities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entities(&mut self) -> &mut ::protobuf::RepeatedField<Entity> {
        &mut self.entities
    }

    // Take field
    pub fn take_entities(&mut self) -> ::protobuf::RepeatedField<Entity> {
        ::std::mem::replace(&mut self.entities, ::protobuf::RepeatedField::new())
    }

    // string language = 2;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeEntitiesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.entities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entities)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.language.is_empty() {
            os.write_string(2, &self.language)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeEntitiesResponse {
        AnalyzeEntitiesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entity>>(
                    "entities",
                    |m: &AnalyzeEntitiesResponse| { &m.entities },
                    |m: &mut AnalyzeEntitiesResponse| { &mut m.entities },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &AnalyzeEntitiesResponse| { &m.language },
                    |m: &mut AnalyzeEntitiesResponse| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnalyzeEntitiesResponse>(
                    "AnalyzeEntitiesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnalyzeEntitiesResponse {
        static mut instance: ::protobuf::lazy::Lazy<AnalyzeEntitiesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnalyzeEntitiesResponse,
        };
        unsafe {
            instance.get(AnalyzeEntitiesResponse::new)
        }
    }
}

impl ::protobuf::Clear for AnalyzeEntitiesResponse {
    fn clear(&mut self) {
        self.entities.clear();
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeEntitiesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeEntitiesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeSyntaxRequest {
    // message fields
    pub document: ::protobuf::SingularPtrField<Document>,
    pub encoding_type: EncodingType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeSyntaxRequest {
    fn default() -> &'a AnalyzeSyntaxRequest {
        <AnalyzeSyntaxRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeSyntaxRequest {
    pub fn new() -> AnalyzeSyntaxRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.Document document = 1;


    pub fn get_document(&self) -> &Document {
        self.document.as_ref().unwrap_or_else(|| Document::default_instance())
    }
    pub fn clear_document(&mut self) {
        self.document.clear();
    }

    pub fn has_document(&self) -> bool {
        self.document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document(&mut self, v: Document) {
        self.document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document(&mut self) -> &mut Document {
        if self.document.is_none() {
            self.document.set_default();
        }
        self.document.as_mut().unwrap()
    }

    // Take field
    pub fn take_document(&mut self) -> Document {
        self.document.take().unwrap_or_else(|| Document::new())
    }

    // .google.cloud.language.v1.EncodingType encoding_type = 2;


    pub fn get_encoding_type(&self) -> EncodingType {
        self.encoding_type
    }
    pub fn clear_encoding_type(&mut self) {
        self.encoding_type = EncodingType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_encoding_type(&mut self, v: EncodingType) {
        self.encoding_type = v;
    }
}

impl ::protobuf::Message for AnalyzeSyntaxRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.encoding_type != EncodingType::NONE {
            my_size += ::protobuf::rt::enum_size(2, self.encoding_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.document.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.encoding_type != EncodingType::NONE {
            os.write_enum(2, self.encoding_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeSyntaxRequest {
        AnalyzeSyntaxRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                    "document",
                    |m: &AnalyzeSyntaxRequest| { &m.document },
                    |m: &mut AnalyzeSyntaxRequest| { &mut m.document },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncodingType>>(
                    "encoding_type",
                    |m: &AnalyzeSyntaxRequest| { &m.encoding_type },
                    |m: &mut AnalyzeSyntaxRequest| { &mut m.encoding_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnalyzeSyntaxRequest>(
                    "AnalyzeSyntaxRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnalyzeSyntaxRequest {
        static mut instance: ::protobuf::lazy::Lazy<AnalyzeSyntaxRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnalyzeSyntaxRequest,
        };
        unsafe {
            instance.get(AnalyzeSyntaxRequest::new)
        }
    }
}

impl ::protobuf::Clear for AnalyzeSyntaxRequest {
    fn clear(&mut self) {
        self.document.clear();
        self.encoding_type = EncodingType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeSyntaxRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeSyntaxRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnalyzeSyntaxResponse {
    // message fields
    pub sentences: ::protobuf::RepeatedField<Sentence>,
    pub tokens: ::protobuf::RepeatedField<Token>,
    pub language: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnalyzeSyntaxResponse {
    fn default() -> &'a AnalyzeSyntaxResponse {
        <AnalyzeSyntaxResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnalyzeSyntaxResponse {
    pub fn new() -> AnalyzeSyntaxResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.language.v1.Sentence sentences = 1;


    pub fn get_sentences(&self) -> &[Sentence] {
        &self.sentences
    }
    pub fn clear_sentences(&mut self) {
        self.sentences.clear();
    }

    // Param is passed by value, moved
    pub fn set_sentences(&mut self, v: ::protobuf::RepeatedField<Sentence>) {
        self.sentences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sentences(&mut self) -> &mut ::protobuf::RepeatedField<Sentence> {
        &mut self.sentences
    }

    // Take field
    pub fn take_sentences(&mut self) -> ::protobuf::RepeatedField<Sentence> {
        ::std::mem::replace(&mut self.sentences, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.language.v1.Token tokens = 2;


    pub fn get_tokens(&self) -> &[Token] {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<Token>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::protobuf::RepeatedField<Token> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<Token> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }

    // string language = 3;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AnalyzeSyntaxResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sentences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sentences)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tokens)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sentences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.language);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sentences {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tokens {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.language.is_empty() {
            os.write_string(3, &self.language)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnalyzeSyntaxResponse {
        AnalyzeSyntaxResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sentence>>(
                    "sentences",
                    |m: &AnalyzeSyntaxResponse| { &m.sentences },
                    |m: &mut AnalyzeSyntaxResponse| { &mut m.sentences },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Token>>(
                    "tokens",
                    |m: &AnalyzeSyntaxResponse| { &m.tokens },
                    |m: &mut AnalyzeSyntaxResponse| { &mut m.tokens },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &AnalyzeSyntaxResponse| { &m.language },
                    |m: &mut AnalyzeSyntaxResponse| { &mut m.language },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnalyzeSyntaxResponse>(
                    "AnalyzeSyntaxResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnalyzeSyntaxResponse {
        static mut instance: ::protobuf::lazy::Lazy<AnalyzeSyntaxResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnalyzeSyntaxResponse,
        };
        unsafe {
            instance.get(AnalyzeSyntaxResponse::new)
        }
    }
}

impl ::protobuf::Clear for AnalyzeSyntaxResponse {
    fn clear(&mut self) {
        self.sentences.clear();
        self.tokens.clear();
        self.language.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnalyzeSyntaxResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnalyzeSyntaxResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClassifyTextRequest {
    // message fields
    pub document: ::protobuf::SingularPtrField<Document>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClassifyTextRequest {
    fn default() -> &'a ClassifyTextRequest {
        <ClassifyTextRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClassifyTextRequest {
    pub fn new() -> ClassifyTextRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.Document document = 1;


    pub fn get_document(&self) -> &Document {
        self.document.as_ref().unwrap_or_else(|| Document::default_instance())
    }
    pub fn clear_document(&mut self) {
        self.document.clear();
    }

    pub fn has_document(&self) -> bool {
        self.document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document(&mut self, v: Document) {
        self.document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document(&mut self) -> &mut Document {
        if self.document.is_none() {
            self.document.set_default();
        }
        self.document.as_mut().unwrap()
    }

    // Take field
    pub fn take_document(&mut self) -> Document {
        self.document.take().unwrap_or_else(|| Document::new())
    }
}

impl ::protobuf::Message for ClassifyTextRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.document.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClassifyTextRequest {
        ClassifyTextRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                    "document",
                    |m: &ClassifyTextRequest| { &m.document },
                    |m: &mut ClassifyTextRequest| { &mut m.document },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClassifyTextRequest>(
                    "ClassifyTextRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClassifyTextRequest {
        static mut instance: ::protobuf::lazy::Lazy<ClassifyTextRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClassifyTextRequest,
        };
        unsafe {
            instance.get(ClassifyTextRequest::new)
        }
    }
}

impl ::protobuf::Clear for ClassifyTextRequest {
    fn clear(&mut self) {
        self.document.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClassifyTextRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClassifyTextRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClassifyTextResponse {
    // message fields
    pub categories: ::protobuf::RepeatedField<ClassificationCategory>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClassifyTextResponse {
    fn default() -> &'a ClassifyTextResponse {
        <ClassifyTextResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClassifyTextResponse {
    pub fn new() -> ClassifyTextResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.language.v1.ClassificationCategory categories = 1;


    pub fn get_categories(&self) -> &[ClassificationCategory] {
        &self.categories
    }
    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::protobuf::RepeatedField<ClassificationCategory>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::protobuf::RepeatedField<ClassificationCategory> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::protobuf::RepeatedField<ClassificationCategory> {
        ::std::mem::replace(&mut self.categories, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ClassifyTextResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.categories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.categories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.categories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.categories {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClassifyTextResponse {
        ClassifyTextResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClassificationCategory>>(
                    "categories",
                    |m: &ClassifyTextResponse| { &m.categories },
                    |m: &mut ClassifyTextResponse| { &mut m.categories },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClassifyTextResponse>(
                    "ClassifyTextResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClassifyTextResponse {
        static mut instance: ::protobuf::lazy::Lazy<ClassifyTextResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClassifyTextResponse,
        };
        unsafe {
            instance.get(ClassifyTextResponse::new)
        }
    }
}

impl ::protobuf::Clear for ClassifyTextResponse {
    fn clear(&mut self) {
        self.categories.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClassifyTextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClassifyTextResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnnotateTextRequest {
    // message fields
    pub document: ::protobuf::SingularPtrField<Document>,
    pub features: ::protobuf::SingularPtrField<AnnotateTextRequest_Features>,
    pub encoding_type: EncodingType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnnotateTextRequest {
    fn default() -> &'a AnnotateTextRequest {
        <AnnotateTextRequest as ::protobuf::Message>::default_instance()
    }
}

impl AnnotateTextRequest {
    pub fn new() -> AnnotateTextRequest {
        ::std::default::Default::default()
    }

    // .google.cloud.language.v1.Document document = 1;


    pub fn get_document(&self) -> &Document {
        self.document.as_ref().unwrap_or_else(|| Document::default_instance())
    }
    pub fn clear_document(&mut self) {
        self.document.clear();
    }

    pub fn has_document(&self) -> bool {
        self.document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document(&mut self, v: Document) {
        self.document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document(&mut self) -> &mut Document {
        if self.document.is_none() {
            self.document.set_default();
        }
        self.document.as_mut().unwrap()
    }

    // Take field
    pub fn take_document(&mut self) -> Document {
        self.document.take().unwrap_or_else(|| Document::new())
    }

    // .google.cloud.language.v1.AnnotateTextRequest.Features features = 2;


    pub fn get_features(&self) -> &AnnotateTextRequest_Features {
        self.features.as_ref().unwrap_or_else(|| AnnotateTextRequest_Features::default_instance())
    }
    pub fn clear_features(&mut self) {
        self.features.clear();
    }

    pub fn has_features(&self) -> bool {
        self.features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_features(&mut self, v: AnnotateTextRequest_Features) {
        self.features = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_features(&mut self) -> &mut AnnotateTextRequest_Features {
        if self.features.is_none() {
            self.features.set_default();
        }
        self.features.as_mut().unwrap()
    }

    // Take field
    pub fn take_features(&mut self) -> AnnotateTextRequest_Features {
        self.features.take().unwrap_or_else(|| AnnotateTextRequest_Features::new())
    }

    // .google.cloud.language.v1.EncodingType encoding_type = 3;


    pub fn get_encoding_type(&self) -> EncodingType {
        self.encoding_type
    }
    pub fn clear_encoding_type(&mut self) {
        self.encoding_type = EncodingType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_encoding_type(&mut self, v: EncodingType) {
        self.encoding_type = v;
    }
}

impl ::protobuf::Message for AnnotateTextRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.features {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.features)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.features.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.encoding_type != EncodingType::NONE {
            my_size += ::protobuf::rt::enum_size(3, self.encoding_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.document.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.features.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.encoding_type != EncodingType::NONE {
            os.write_enum(3, self.encoding_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnnotateTextRequest {
        AnnotateTextRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                    "document",
                    |m: &AnnotateTextRequest| { &m.document },
                    |m: &mut AnnotateTextRequest| { &mut m.document },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AnnotateTextRequest_Features>>(
                    "features",
                    |m: &AnnotateTextRequest| { &m.features },
                    |m: &mut AnnotateTextRequest| { &mut m.features },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncodingType>>(
                    "encoding_type",
                    |m: &AnnotateTextRequest| { &m.encoding_type },
                    |m: &mut AnnotateTextRequest| { &mut m.encoding_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnnotateTextRequest>(
                    "AnnotateTextRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnnotateTextRequest {
        static mut instance: ::protobuf::lazy::Lazy<AnnotateTextRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnnotateTextRequest,
        };
        unsafe {
            instance.get(AnnotateTextRequest::new)
        }
    }
}

impl ::protobuf::Clear for AnnotateTextRequest {
    fn clear(&mut self) {
        self.document.clear();
        self.features.clear();
        self.encoding_type = EncodingType::NONE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnnotateTextRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotateTextRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnnotateTextRequest_Features {
    // message fields
    pub extract_syntax: bool,
    pub extract_entities: bool,
    pub extract_document_sentiment: bool,
    pub extract_entity_sentiment: bool,
    pub classify_text: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnnotateTextRequest_Features {
    fn default() -> &'a AnnotateTextRequest_Features {
        <AnnotateTextRequest_Features as ::protobuf::Message>::default_instance()
    }
}

impl AnnotateTextRequest_Features {
    pub fn new() -> AnnotateTextRequest_Features {
        ::std::default::Default::default()
    }

    // bool extract_syntax = 1;


    pub fn get_extract_syntax(&self) -> bool {
        self.extract_syntax
    }
    pub fn clear_extract_syntax(&mut self) {
        self.extract_syntax = false;
    }

    // Param is passed by value, moved
    pub fn set_extract_syntax(&mut self, v: bool) {
        self.extract_syntax = v;
    }

    // bool extract_entities = 2;


    pub fn get_extract_entities(&self) -> bool {
        self.extract_entities
    }
    pub fn clear_extract_entities(&mut self) {
        self.extract_entities = false;
    }

    // Param is passed by value, moved
    pub fn set_extract_entities(&mut self, v: bool) {
        self.extract_entities = v;
    }

    // bool extract_document_sentiment = 3;


    pub fn get_extract_document_sentiment(&self) -> bool {
        self.extract_document_sentiment
    }
    pub fn clear_extract_document_sentiment(&mut self) {
        self.extract_document_sentiment = false;
    }

    // Param is passed by value, moved
    pub fn set_extract_document_sentiment(&mut self, v: bool) {
        self.extract_document_sentiment = v;
    }

    // bool extract_entity_sentiment = 4;


    pub fn get_extract_entity_sentiment(&self) -> bool {
        self.extract_entity_sentiment
    }
    pub fn clear_extract_entity_sentiment(&mut self) {
        self.extract_entity_sentiment = false;
    }

    // Param is passed by value, moved
    pub fn set_extract_entity_sentiment(&mut self, v: bool) {
        self.extract_entity_sentiment = v;
    }

    // bool classify_text = 6;


    pub fn get_classify_text(&self) -> bool {
        self.classify_text
    }
    pub fn clear_classify_text(&mut self) {
        self.classify_text = false;
    }

    // Param is passed by value, moved
    pub fn set_classify_text(&mut self, v: bool) {
        self.classify_text = v;
    }
}

impl ::protobuf::Message for AnnotateTextRequest_Features {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.extract_syntax = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.extract_entities = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.extract_document_sentiment = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.extract_entity_sentiment = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.classify_text = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.extract_syntax != false {
            my_size += 2;
        }
        if self.extract_entities != false {
            my_size += 2;
        }
        if self.extract_document_sentiment != false {
            my_size += 2;
        }
        if self.extract_entity_sentiment != false {
            my_size += 2;
        }
        if self.classify_text != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.extract_syntax != false {
            os.write_bool(1, self.extract_syntax)?;
        }
        if self.extract_entities != false {
            os.write_bool(2, self.extract_entities)?;
        }
        if self.extract_document_sentiment != false {
            os.write_bool(3, self.extract_document_sentiment)?;
        }
        if self.extract_entity_sentiment != false {
            os.write_bool(4, self.extract_entity_sentiment)?;
        }
        if self.classify_text != false {
            os.write_bool(6, self.classify_text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnnotateTextRequest_Features {
        AnnotateTextRequest_Features::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "extract_syntax",
                    |m: &AnnotateTextRequest_Features| { &m.extract_syntax },
                    |m: &mut AnnotateTextRequest_Features| { &mut m.extract_syntax },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "extract_entities",
                    |m: &AnnotateTextRequest_Features| { &m.extract_entities },
                    |m: &mut AnnotateTextRequest_Features| { &mut m.extract_entities },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "extract_document_sentiment",
                    |m: &AnnotateTextRequest_Features| { &m.extract_document_sentiment },
                    |m: &mut AnnotateTextRequest_Features| { &mut m.extract_document_sentiment },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "extract_entity_sentiment",
                    |m: &AnnotateTextRequest_Features| { &m.extract_entity_sentiment },
                    |m: &mut AnnotateTextRequest_Features| { &mut m.extract_entity_sentiment },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "classify_text",
                    |m: &AnnotateTextRequest_Features| { &m.classify_text },
                    |m: &mut AnnotateTextRequest_Features| { &mut m.classify_text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnnotateTextRequest_Features>(
                    "AnnotateTextRequest_Features",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnnotateTextRequest_Features {
        static mut instance: ::protobuf::lazy::Lazy<AnnotateTextRequest_Features> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnnotateTextRequest_Features,
        };
        unsafe {
            instance.get(AnnotateTextRequest_Features::new)
        }
    }
}

impl ::protobuf::Clear for AnnotateTextRequest_Features {
    fn clear(&mut self) {
        self.extract_syntax = false;
        self.extract_entities = false;
        self.extract_document_sentiment = false;
        self.extract_entity_sentiment = false;
        self.classify_text = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnnotateTextRequest_Features {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotateTextRequest_Features {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AnnotateTextResponse {
    // message fields
    pub sentences: ::protobuf::RepeatedField<Sentence>,
    pub tokens: ::protobuf::RepeatedField<Token>,
    pub entities: ::protobuf::RepeatedField<Entity>,
    pub document_sentiment: ::protobuf::SingularPtrField<Sentiment>,
    pub language: ::std::string::String,
    pub categories: ::protobuf::RepeatedField<ClassificationCategory>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AnnotateTextResponse {
    fn default() -> &'a AnnotateTextResponse {
        <AnnotateTextResponse as ::protobuf::Message>::default_instance()
    }
}

impl AnnotateTextResponse {
    pub fn new() -> AnnotateTextResponse {
        ::std::default::Default::default()
    }

    // repeated .google.cloud.language.v1.Sentence sentences = 1;


    pub fn get_sentences(&self) -> &[Sentence] {
        &self.sentences
    }
    pub fn clear_sentences(&mut self) {
        self.sentences.clear();
    }

    // Param is passed by value, moved
    pub fn set_sentences(&mut self, v: ::protobuf::RepeatedField<Sentence>) {
        self.sentences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sentences(&mut self) -> &mut ::protobuf::RepeatedField<Sentence> {
        &mut self.sentences
    }

    // Take field
    pub fn take_sentences(&mut self) -> ::protobuf::RepeatedField<Sentence> {
        ::std::mem::replace(&mut self.sentences, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.language.v1.Token tokens = 2;


    pub fn get_tokens(&self) -> &[Token] {
        &self.tokens
    }
    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<Token>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens(&mut self) -> &mut ::protobuf::RepeatedField<Token> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<Token> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }

    // repeated .google.cloud.language.v1.Entity entities = 3;


    pub fn get_entities(&self) -> &[Entity] {
        &self.entities
    }
    pub fn clear_entities(&mut self) {
        self.entities.clear();
    }

    // Param is passed by value, moved
    pub fn set_entities(&mut self, v: ::protobuf::RepeatedField<Entity>) {
        self.entities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entities(&mut self) -> &mut ::protobuf::RepeatedField<Entity> {
        &mut self.entities
    }

    // Take field
    pub fn take_entities(&mut self) -> ::protobuf::RepeatedField<Entity> {
        ::std::mem::replace(&mut self.entities, ::protobuf::RepeatedField::new())
    }

    // .google.cloud.language.v1.Sentiment document_sentiment = 4;


    pub fn get_document_sentiment(&self) -> &Sentiment {
        self.document_sentiment.as_ref().unwrap_or_else(|| Sentiment::default_instance())
    }
    pub fn clear_document_sentiment(&mut self) {
        self.document_sentiment.clear();
    }

    pub fn has_document_sentiment(&self) -> bool {
        self.document_sentiment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document_sentiment(&mut self, v: Sentiment) {
        self.document_sentiment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document_sentiment(&mut self) -> &mut Sentiment {
        if self.document_sentiment.is_none() {
            self.document_sentiment.set_default();
        }
        self.document_sentiment.as_mut().unwrap()
    }

    // Take field
    pub fn take_document_sentiment(&mut self) -> Sentiment {
        self.document_sentiment.take().unwrap_or_else(|| Sentiment::new())
    }

    // string language = 5;


    pub fn get_language(&self) -> &str {
        &self.language
    }
    pub fn clear_language(&mut self) {
        self.language.clear();
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        &mut self.language
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.language, ::std::string::String::new())
    }

    // repeated .google.cloud.language.v1.ClassificationCategory categories = 6;


    pub fn get_categories(&self) -> &[ClassificationCategory] {
        &self.categories
    }
    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::protobuf::RepeatedField<ClassificationCategory>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::protobuf::RepeatedField<ClassificationCategory> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::protobuf::RepeatedField<ClassificationCategory> {
        ::std::mem::replace(&mut self.categories, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AnnotateTextResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sentences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tokens {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.document_sentiment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.categories {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sentences)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tokens)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entities)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document_sentiment)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.language)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.categories)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sentences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tokens {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.entities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.document_sentiment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.language.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.language);
        }
        for value in &self.categories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sentences {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tokens {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.entities {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.document_sentiment.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.language.is_empty() {
            os.write_string(5, &self.language)?;
        }
        for v in &self.categories {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AnnotateTextResponse {
        AnnotateTextResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sentence>>(
                    "sentences",
                    |m: &AnnotateTextResponse| { &m.sentences },
                    |m: &mut AnnotateTextResponse| { &mut m.sentences },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Token>>(
                    "tokens",
                    |m: &AnnotateTextResponse| { &m.tokens },
                    |m: &mut AnnotateTextResponse| { &mut m.tokens },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entity>>(
                    "entities",
                    |m: &AnnotateTextResponse| { &m.entities },
                    |m: &mut AnnotateTextResponse| { &mut m.entities },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sentiment>>(
                    "document_sentiment",
                    |m: &AnnotateTextResponse| { &m.document_sentiment },
                    |m: &mut AnnotateTextResponse| { &mut m.document_sentiment },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "language",
                    |m: &AnnotateTextResponse| { &m.language },
                    |m: &mut AnnotateTextResponse| { &mut m.language },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClassificationCategory>>(
                    "categories",
                    |m: &AnnotateTextResponse| { &m.categories },
                    |m: &mut AnnotateTextResponse| { &mut m.categories },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AnnotateTextResponse>(
                    "AnnotateTextResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AnnotateTextResponse {
        static mut instance: ::protobuf::lazy::Lazy<AnnotateTextResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AnnotateTextResponse,
        };
        unsafe {
            instance.get(AnnotateTextResponse::new)
        }
    }
}

impl ::protobuf::Clear for AnnotateTextResponse {
    fn clear(&mut self) {
        self.sentences.clear();
        self.tokens.clear();
        self.entities.clear();
        self.document_sentiment.clear();
        self.language.clear();
        self.categories.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AnnotateTextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AnnotateTextResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncodingType {
    NONE = 0,
    UTF8 = 1,
    UTF16 = 2,
    UTF32 = 3,
}

impl ::protobuf::ProtobufEnum for EncodingType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncodingType> {
        match value {
            0 => ::std::option::Option::Some(EncodingType::NONE),
            1 => ::std::option::Option::Some(EncodingType::UTF8),
            2 => ::std::option::Option::Some(EncodingType::UTF16),
            3 => ::std::option::Option::Some(EncodingType::UTF32),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncodingType] = &[
            EncodingType::NONE,
            EncodingType::UTF8,
            EncodingType::UTF16,
            EncodingType::UTF32,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EncodingType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EncodingType {
}

impl ::std::default::Default for EncodingType {
    fn default() -> Self {
        EncodingType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for EncodingType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n/google/cloud/language/v1/language_service.proto\x12\x18google.cloud.l\
    anguage.v1\x1a\x1cgoogle/api/annotations.proto\"\xeb\x01\n\x08Document\
    \x12;\n\x04type\x18\x01\x20\x01(\x0e2'.google.cloud.language.v1.Document\
    .TypeR\x04type\x12\x1a\n\x07content\x18\x02\x20\x01(\tH\0R\x07content\
    \x12(\n\x0fgcs_content_uri\x18\x03\x20\x01(\tH\0R\rgcsContentUri\x12\x1a\
    \n\x08language\x18\x04\x20\x01(\tR\x08language\"6\n\x04Type\x12\x14\n\
    \x10TYPE_UNSPECIFIED\x10\0\x12\x0e\n\nPLAIN_TEXT\x10\x01\x12\x08\n\x04HT\
    ML\x10\x02B\x08\n\x06source\"\x85\x01\n\x08Sentence\x126\n\x04text\x18\
    \x01\x20\x01(\x0b2\".google.cloud.language.v1.TextSpanR\x04text\x12A\n\t\
    sentiment\x18\x02\x20\x01(\x0b2#.google.cloud.language.v1.SentimentR\tse\
    ntiment\"\xff\x03\n\x06Entity\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04n\
    ame\x129\n\x04type\x18\x02\x20\x01(\x0e2%.google.cloud.language.v1.Entit\
    y.TypeR\x04type\x12J\n\x08metadata\x18\x03\x20\x03(\x0b2..google.cloud.l\
    anguage.v1.Entity.MetadataEntryR\x08metadata\x12\x1a\n\x08salience\x18\
    \x04\x20\x01(\x02R\x08salience\x12C\n\x08mentions\x18\x05\x20\x03(\x0b2'\
    .google.cloud.language.v1.EntityMentionR\x08mentions\x12A\n\tsentiment\
    \x18\x06\x20\x01(\x0b2#.google.cloud.language.v1.SentimentR\tsentiment\
    \x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"y\n\x04Type\x12\
    \x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06PERSON\x10\x01\x12\x0c\n\x08LOCATION\
    \x10\x02\x12\x10\n\x0cORGANIZATION\x10\x03\x12\t\n\x05EVENT\x10\x04\x12\
    \x0f\n\x0bWORK_OF_ART\x10\x05\x12\x11\n\rCONSUMER_GOOD\x10\x06\x12\t\n\
    \x05OTHER\x10\x07\"\xf6\x01\n\x05Token\x126\n\x04text\x18\x01\x20\x01(\
    \x0b2\".google.cloud.language.v1.TextSpanR\x04text\x12L\n\x0epart_of_spe\
    ech\x18\x02\x20\x01(\x0b2&.google.cloud.language.v1.PartOfSpeechR\x0cpar\
    tOfSpeech\x12Q\n\x0fdependency_edge\x18\x03\x20\x01(\x0b2(.google.cloud.\
    language.v1.DependencyEdgeR\x0edependencyEdge\x12\x14\n\x05lemma\x18\x04\
    \x20\x01(\tR\x05lemma\"?\n\tSentiment\x12\x1c\n\tmagnitude\x18\x02\x20\
    \x01(\x02R\tmagnitude\x12\x14\n\x05score\x18\x03\x20\x01(\x02R\x05score\
    \"\xfd\x10\n\x0cPartOfSpeech\x12<\n\x03tag\x18\x01\x20\x01(\x0e2*.google\
    .cloud.language.v1.PartOfSpeech.TagR\x03tag\x12E\n\x06aspect\x18\x02\x20\
    \x01(\x0e2-.google.cloud.language.v1.PartOfSpeech.AspectR\x06aspect\x12?\
    \n\x04case\x18\x03\x20\x01(\x0e2+.google.cloud.language.v1.PartOfSpeech.\
    CaseR\x04case\x12?\n\x04form\x18\x04\x20\x01(\x0e2+.google.cloud.languag\
    e.v1.PartOfSpeech.FormR\x04form\x12E\n\x06gender\x18\x05\x20\x01(\x0e2-.\
    google.cloud.language.v1.PartOfSpeech.GenderR\x06gender\x12?\n\x04mood\
    \x18\x06\x20\x01(\x0e2+.google.cloud.language.v1.PartOfSpeech.MoodR\x04m\
    ood\x12E\n\x06number\x18\x07\x20\x01(\x0e2-.google.cloud.language.v1.Par\
    tOfSpeech.NumberR\x06number\x12E\n\x06person\x18\x08\x20\x01(\x0e2-.goog\
    le.cloud.language.v1.PartOfSpeech.PersonR\x06person\x12E\n\x06proper\x18\
    \t\x20\x01(\x0e2-.google.cloud.language.v1.PartOfSpeech.ProperR\x06prope\
    r\x12T\n\x0breciprocity\x18\n\x20\x01(\x0e22.google.cloud.language.v1.Pa\
    rtOfSpeech.ReciprocityR\x0breciprocity\x12B\n\x05tense\x18\x0b\x20\x01(\
    \x0e2,.google.cloud.language.v1.PartOfSpeech.TenseR\x05tense\x12B\n\x05v\
    oice\x18\x0c\x20\x01(\x0e2,.google.cloud.language.v1.PartOfSpeech.VoiceR\
    \x05voice\"\x8d\x01\n\x03Tag\x12\x0b\n\x07UNKNOWN\x10\0\x12\x07\n\x03ADJ\
    \x10\x01\x12\x07\n\x03ADP\x10\x02\x12\x07\n\x03ADV\x10\x03\x12\x08\n\x04\
    CONJ\x10\x04\x12\x07\n\x03DET\x10\x05\x12\x08\n\x04NOUN\x10\x06\x12\x07\
    \n\x03NUM\x10\x07\x12\x08\n\x04PRON\x10\x08\x12\x07\n\x03PRT\x10\t\x12\t\
    \n\x05PUNCT\x10\n\x12\x08\n\x04VERB\x10\x0b\x12\x05\n\x01X\x10\x0c\x12\t\
    \n\x05AFFIX\x10\r\"O\n\x06Aspect\x12\x12\n\x0eASPECT_UNKNOWN\x10\0\x12\
    \x0e\n\nPERFECTIVE\x10\x01\x12\x10\n\x0cIMPERFECTIVE\x10\x02\x12\x0f\n\
    \x0bPROGRESSIVE\x10\x03\"\xf8\x01\n\x04Case\x12\x10\n\x0cCASE_UNKNOWN\
    \x10\0\x12\x0e\n\nACCUSATIVE\x10\x01\x12\r\n\tADVERBIAL\x10\x02\x12\x11\
    \n\rCOMPLEMENTIVE\x10\x03\x12\n\n\x06DATIVE\x10\x04\x12\x0c\n\x08GENITIV\
    E\x10\x05\x12\x10\n\x0cINSTRUMENTAL\x10\x06\x12\x0c\n\x08LOCATIVE\x10\
    \x07\x12\x0e\n\nNOMINATIVE\x10\x08\x12\x0b\n\x07OBLIQUE\x10\t\x12\r\n\tP\
    ARTITIVE\x10\n\x12\x11\n\rPREPOSITIONAL\x10\x0b\x12\x12\n\x0eREFLEXIVE_C\
    ASE\x10\x0c\x12\x11\n\rRELATIVE_CASE\x10\r\x12\x0c\n\x08VOCATIVE\x10\x0e\
    \"\xaf\x01\n\x04Form\x12\x10\n\x0cFORM_UNKNOWN\x10\0\x12\x0c\n\x08ADNOMI\
    AL\x10\x01\x12\r\n\tAUXILIARY\x10\x02\x12\x12\n\x0eCOMPLEMENTIZER\x10\
    \x03\x12\x10\n\x0cFINAL_ENDING\x10\x04\x12\n\n\x06GERUND\x10\x05\x12\n\n\
    \x06REALIS\x10\x06\x12\x0c\n\x08IRREALIS\x10\x07\x12\t\n\x05SHORT\x10\
    \x08\x12\x08\n\x04LONG\x10\t\x12\t\n\x05ORDER\x10\n\x12\x0c\n\x08SPECIFI\
    C\x10\x0b\"E\n\x06Gender\x12\x12\n\x0eGENDER_UNKNOWN\x10\0\x12\x0c\n\x08\
    FEMININE\x10\x01\x12\r\n\tMASCULINE\x10\x02\x12\n\n\x06NEUTER\x10\x03\"\
    \x7f\n\x04Mood\x12\x10\n\x0cMOOD_UNKNOWN\x10\0\x12\x14\n\x10CONDITIONAL_\
    MOOD\x10\x01\x12\x0e\n\nIMPERATIVE\x10\x02\x12\x0e\n\nINDICATIVE\x10\x03\
    \x12\x11\n\rINTERROGATIVE\x10\x04\x12\x0b\n\x07JUSSIVE\x10\x05\x12\x0f\n\
    \x0bSUBJUNCTIVE\x10\x06\"@\n\x06Number\x12\x12\n\x0eNUMBER_UNKNOWN\x10\0\
    \x12\x0c\n\x08SINGULAR\x10\x01\x12\n\n\x06PLURAL\x10\x02\x12\x08\n\x04DU\
    AL\x10\x03\"T\n\x06Person\x12\x12\n\x0ePERSON_UNKNOWN\x10\0\x12\t\n\x05F\
    IRST\x10\x01\x12\n\n\x06SECOND\x10\x02\x12\t\n\x05THIRD\x10\x03\x12\x14\
    \n\x10REFLEXIVE_PERSON\x10\x04\"8\n\x06Proper\x12\x12\n\x0ePROPER_UNKNOW\
    N\x10\0\x12\n\n\x06PROPER\x10\x01\x12\x0e\n\nNOT_PROPER\x10\x02\"J\n\x0b\
    Reciprocity\x12\x17\n\x13RECIPROCITY_UNKNOWN\x10\0\x12\x0e\n\nRECIPROCAL\
    \x10\x01\x12\x12\n\x0eNON_RECIPROCAL\x10\x02\"s\n\x05Tense\x12\x11\n\rTE\
    NSE_UNKNOWN\x10\0\x12\x15\n\x11CONDITIONAL_TENSE\x10\x01\x12\n\n\x06FUTU\
    RE\x10\x02\x12\x08\n\x04PAST\x10\x03\x12\x0b\n\x07PRESENT\x10\x04\x12\r\
    \n\tIMPERFECT\x10\x05\x12\x0e\n\nPLUPERFECT\x10\x06\"B\n\x05Voice\x12\
    \x11\n\rVOICE_UNKNOWN\x10\0\x12\n\n\x06ACTIVE\x10\x01\x12\r\n\tCAUSATIVE\
    \x10\x02\x12\x0b\n\x07PASSIVE\x10\x03\"\xac\x08\n\x0eDependencyEdge\x12(\
    \n\x10head_token_index\x18\x01\x20\x01(\x05R\x0eheadTokenIndex\x12D\n\
    \x05label\x18\x02\x20\x01(\x0e2..google.cloud.language.v1.DependencyEdge\
    .LabelR\x05label\"\xa9\x07\n\x05Label\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\
    \x06ABBREV\x10\x01\x12\t\n\x05ACOMP\x10\x02\x12\t\n\x05ADVCL\x10\x03\x12\
    \n\n\x06ADVMOD\x10\x04\x12\x08\n\x04AMOD\x10\x05\x12\t\n\x05APPOS\x10\
    \x06\x12\x08\n\x04ATTR\x10\x07\x12\x07\n\x03AUX\x10\x08\x12\x0b\n\x07AUX\
    PASS\x10\t\x12\x06\n\x02CC\x10\n\x12\t\n\x05CCOMP\x10\x0b\x12\x08\n\x04C\
    ONJ\x10\x0c\x12\t\n\x05CSUBJ\x10\r\x12\r\n\tCSUBJPASS\x10\x0e\x12\x07\n\
    \x03DEP\x10\x0f\x12\x07\n\x03DET\x10\x10\x12\r\n\tDISCOURSE\x10\x11\x12\
    \x08\n\x04DOBJ\x10\x12\x12\x08\n\x04EXPL\x10\x13\x12\x0c\n\x08GOESWITH\
    \x10\x14\x12\x08\n\x04IOBJ\x10\x15\x12\x08\n\x04MARK\x10\x16\x12\x07\n\
    \x03MWE\x10\x17\x12\x07\n\x03MWV\x10\x18\x12\x07\n\x03NEG\x10\x19\x12\
    \x06\n\x02NN\x10\x1a\x12\x0c\n\x08NPADVMOD\x10\x1b\x12\t\n\x05NSUBJ\x10\
    \x1c\x12\r\n\tNSUBJPASS\x10\x1d\x12\x07\n\x03NUM\x10\x1e\x12\n\n\x06NUMB\
    ER\x10\x1f\x12\x05\n\x01P\x10\x20\x12\r\n\tPARATAXIS\x10!\x12\x0b\n\x07P\
    ARTMOD\x10\"\x12\t\n\x05PCOMP\x10#\x12\x08\n\x04POBJ\x10$\x12\x08\n\x04P\
    OSS\x10%\x12\x0b\n\x07POSTNEG\x10&\x12\x0b\n\x07PRECOMP\x10'\x12\x0b\n\
    \x07PRECONJ\x10(\x12\n\n\x06PREDET\x10)\x12\x08\n\x04PREF\x10*\x12\x08\n\
    \x04PREP\x10+\x12\t\n\x05PRONL\x10,\x12\x07\n\x03PRT\x10-\x12\x06\n\x02P\
    S\x10.\x12\x0c\n\x08QUANTMOD\x10/\x12\t\n\x05RCMOD\x100\x12\x0c\n\x08RCM\
    ODREL\x101\x12\t\n\x05RDROP\x102\x12\x07\n\x03REF\x103\x12\x0b\n\x07REMN\
    ANT\x104\x12\x0e\n\nREPARANDUM\x105\x12\x08\n\x04ROOT\x106\x12\x08\n\x04\
    SNUM\x107\x12\x08\n\x04SUFF\x108\x12\x08\n\x04TMOD\x109\x12\t\n\x05TOPIC\
    \x10:\x12\x08\n\x04VMOD\x10;\x12\x0c\n\x08VOCATIVE\x10<\x12\t\n\x05XCOMP\
    \x10=\x12\n\n\x06SUFFIX\x10>\x12\t\n\x05TITLE\x10?\x12\x0c\n\x08ADVPHMOD\
    \x10@\x12\x0b\n\x07AUXCAUS\x10A\x12\t\n\x05AUXVV\x10B\x12\t\n\x05DTMOD\
    \x10C\x12\x0b\n\x07FOREIGN\x10D\x12\x06\n\x02KW\x10E\x12\x08\n\x04LIST\
    \x10F\x12\x08\n\x04NOMC\x10G\x12\x0c\n\x08NOMCSUBJ\x10H\x12\x10\n\x0cNOM\
    CSUBJPASS\x10I\x12\x08\n\x04NUMC\x10J\x12\x07\n\x03COP\x10K\x12\x0e\n\nD\
    ISLOCATED\x10L\x12\x07\n\x03ASP\x10M\x12\x08\n\x04GMOD\x10N\x12\x08\n\
    \x04GOBJ\x10O\x12\n\n\x06INFMOD\x10P\x12\x07\n\x03MES\x10Q\x12\t\n\x05NC\
    OMP\x10R\"\xfe\x01\n\rEntityMention\x126\n\x04text\x18\x01\x20\x01(\x0b2\
    \".google.cloud.language.v1.TextSpanR\x04text\x12@\n\x04type\x18\x02\x20\
    \x01(\x0e2,.google.cloud.language.v1.EntityMention.TypeR\x04type\x12A\n\
    \tsentiment\x18\x03\x20\x01(\x0b2#.google.cloud.language.v1.SentimentR\t\
    sentiment\"0\n\x04Type\x12\x10\n\x0cTYPE_UNKNOWN\x10\0\x12\n\n\x06PROPER\
    \x10\x01\x12\n\n\x06COMMON\x10\x02\"G\n\x08TextSpan\x12\x18\n\x07content\
    \x18\x01\x20\x01(\tR\x07content\x12!\n\x0cbegin_offset\x18\x02\x20\x01(\
    \x05R\x0bbeginOffset\"L\n\x16ClassificationCategory\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x1e\n\nconfidence\x18\x02\x20\x01(\x02R\
    \nconfidence\"\xa6\x01\n\x17AnalyzeSentimentRequest\x12>\n\x08document\
    \x18\x01\x20\x01(\x0b2\".google.cloud.language.v1.DocumentR\x08document\
    \x12K\n\rencoding_type\x18\x02\x20\x01(\x0e2&.google.cloud.language.v1.E\
    ncodingTypeR\x0cencodingType\"\xcc\x01\n\x18AnalyzeSentimentResponse\x12\
    R\n\x12document_sentiment\x18\x01\x20\x01(\x0b2#.google.cloud.language.v\
    1.SentimentR\x11documentSentiment\x12\x1a\n\x08language\x18\x02\x20\x01(\
    \tR\x08language\x12@\n\tsentences\x18\x03\x20\x03(\x0b2\".google.cloud.l\
    anguage.v1.SentenceR\tsentences\"\xac\x01\n\x1dAnalyzeEntitySentimentReq\
    uest\x12>\n\x08document\x18\x01\x20\x01(\x0b2\".google.cloud.language.v1\
    .DocumentR\x08document\x12K\n\rencoding_type\x18\x02\x20\x01(\x0e2&.goog\
    le.cloud.language.v1.EncodingTypeR\x0cencodingType\"z\n\x1eAnalyzeEntity\
    SentimentResponse\x12<\n\x08entities\x18\x01\x20\x03(\x0b2\x20.google.cl\
    oud.language.v1.EntityR\x08entities\x12\x1a\n\x08language\x18\x02\x20\
    \x01(\tR\x08language\"\xa5\x01\n\x16AnalyzeEntitiesRequest\x12>\n\x08doc\
    ument\x18\x01\x20\x01(\x0b2\".google.cloud.language.v1.DocumentR\x08docu\
    ment\x12K\n\rencoding_type\x18\x02\x20\x01(\x0e2&.google.cloud.language.\
    v1.EncodingTypeR\x0cencodingType\"s\n\x17AnalyzeEntitiesResponse\x12<\n\
    \x08entities\x18\x01\x20\x03(\x0b2\x20.google.cloud.language.v1.EntityR\
    \x08entities\x12\x1a\n\x08language\x18\x02\x20\x01(\tR\x08language\"\xa3\
    \x01\n\x14AnalyzeSyntaxRequest\x12>\n\x08document\x18\x01\x20\x01(\x0b2\
    \".google.cloud.language.v1.DocumentR\x08document\x12K\n\rencoding_type\
    \x18\x02\x20\x01(\x0e2&.google.cloud.language.v1.EncodingTypeR\x0cencodi\
    ngType\"\xae\x01\n\x15AnalyzeSyntaxResponse\x12@\n\tsentences\x18\x01\
    \x20\x03(\x0b2\".google.cloud.language.v1.SentenceR\tsentences\x127\n\
    \x06tokens\x18\x02\x20\x03(\x0b2\x1f.google.cloud.language.v1.TokenR\x06\
    tokens\x12\x1a\n\x08language\x18\x03\x20\x01(\tR\x08language\"U\n\x13Cla\
    ssifyTextRequest\x12>\n\x08document\x18\x01\x20\x01(\x0b2\".google.cloud\
    .language.v1.DocumentR\x08document\"h\n\x14ClassifyTextResponse\x12P\n\n\
    categories\x18\x01\x20\x03(\x0b20.google.cloud.language.v1.Classificatio\
    nCategoryR\ncategories\"\xf2\x03\n\x13AnnotateTextRequest\x12>\n\x08docu\
    ment\x18\x01\x20\x01(\x0b2\".google.cloud.language.v1.DocumentR\x08docum\
    ent\x12R\n\x08features\x18\x02\x20\x01(\x0b26.google.cloud.language.v1.A\
    nnotateTextRequest.FeaturesR\x08features\x12K\n\rencoding_type\x18\x03\
    \x20\x01(\x0e2&.google.cloud.language.v1.EncodingTypeR\x0cencodingType\
    \x1a\xf9\x01\n\x08Features\x12%\n\x0eextract_syntax\x18\x01\x20\x01(\x08\
    R\rextractSyntax\x12)\n\x10extract_entities\x18\x02\x20\x01(\x08R\x0fext\
    ractEntities\x12<\n\x1aextract_document_sentiment\x18\x03\x20\x01(\x08R\
    \x18extractDocumentSentiment\x128\n\x18extract_entity_sentiment\x18\x04\
    \x20\x01(\x08R\x16extractEntitySentiment\x12#\n\rclassify_text\x18\x06\
    \x20\x01(\x08R\x0cclassifyText\"\x91\x03\n\x14AnnotateTextResponse\x12@\
    \n\tsentences\x18\x01\x20\x03(\x0b2\".google.cloud.language.v1.SentenceR\
    \tsentences\x127\n\x06tokens\x18\x02\x20\x03(\x0b2\x1f.google.cloud.lang\
    uage.v1.TokenR\x06tokens\x12<\n\x08entities\x18\x03\x20\x03(\x0b2\x20.go\
    ogle.cloud.language.v1.EntityR\x08entities\x12R\n\x12document_sentiment\
    \x18\x04\x20\x01(\x0b2#.google.cloud.language.v1.SentimentR\x11documentS\
    entiment\x12\x1a\n\x08language\x18\x05\x20\x01(\tR\x08language\x12P\n\nc\
    ategories\x18\x06\x20\x03(\x0b20.google.cloud.language.v1.Classification\
    CategoryR\ncategories*8\n\x0cEncodingType\x12\x08\n\x04NONE\x10\0\x12\
    \x08\n\x04UTF8\x10\x01\x12\t\n\x05UTF16\x10\x02\x12\t\n\x05UTF32\x10\x03\
    2\xe3\x07\n\x0fLanguageService\x12\xa4\x01\n\x10AnalyzeSentiment\x121.go\
    ogle.cloud.language.v1.AnalyzeSentimentRequest\x1a2.google.cloud.languag\
    e.v1.AnalyzeSentimentResponse\")\x82\xd3\xe4\x93\x02#\"\x1e/v1/documents\
    :analyzeSentiment:\x01*\x12\xa0\x01\n\x0fAnalyzeEntities\x120.google.clo\
    ud.language.v1.AnalyzeEntitiesRequest\x1a1.google.cloud.language.v1.Anal\
    yzeEntitiesResponse\"(\x82\xd3\xe4\x93\x02\"\"\x1d/v1/documents:analyzeE\
    ntities:\x01*\x12\xbc\x01\n\x16AnalyzeEntitySentiment\x127.google.cloud.\
    language.v1.AnalyzeEntitySentimentRequest\x1a8.google.cloud.language.v1.\
    AnalyzeEntitySentimentResponse\"/\x82\xd3\xe4\x93\x02)\"$/v1/documents:a\
    nalyzeEntitySentiment:\x01*\x12\x98\x01\n\rAnalyzeSyntax\x12..google.clo\
    ud.language.v1.AnalyzeSyntaxRequest\x1a/.google.cloud.language.v1.Analyz\
    eSyntaxResponse\"&\x82\xd3\xe4\x93\x02\x20\"\x1b/v1/documents:analyzeSyn\
    tax:\x01*\x12\x94\x01\n\x0cClassifyText\x12-.google.cloud.language.v1.Cl\
    assifyTextRequest\x1a..google.cloud.language.v1.ClassifyTextResponse\"%\
    \x82\xd3\xe4\x93\x02\x1f\"\x1a/v1/documents:classifyText:\x01*\x12\x94\
    \x01\n\x0cAnnotateText\x12-.google.cloud.language.v1.AnnotateTextRequest\
    \x1a..google.cloud.language.v1.AnnotateTextResponse\"%\x82\xd3\xe4\x93\
    \x02\x1f\"\x1a/v1/documents:annotateText:\x01*Bx\n\x1ccom.google.cloud.l\
    anguage.v1B\x14LanguageServiceProtoP\x01Z@google.golang.org/genproto/goo\
    gleapis/cloud/language/v1;languageJ\x80\x84\x02\n\x07\x12\x05\x0e\0\x8f\
    \x08\x01\n\xbd\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb2\x04\x20Copyright\x20\
    2017\x20Google\x20Inc.\n\n\x20Licensed\x20under\x20the\x20Apache\x20Lice\
    nse,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\
    \x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20\
    License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\
    \x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\
    \n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\0!\n\t\
    \n\x02\x03\0\x12\x03\x12\0&\n\x08\n\x01\x08\x12\x03\x14\0W\n\t\n\x02\x08\
    \x0b\x12\x03\x14\0W\n\x08\n\x01\x08\x12\x03\x15\0\"\n\t\n\x02\x08\n\x12\
    \x03\x15\0\"\n\x08\n\x01\x08\x12\x03\x16\05\n\t\n\x02\x08\x08\x12\x03\
    \x16\05\n\x08\n\x01\x08\x12\x03\x17\05\n\t\n\x02\x08\x01\x12\x03\x17\05\
    \nc\n\x02\x06\0\x12\x04\x1c\0@\x01\x1aW\x20Provides\x20text\x20analysis\
    \x20operations\x20such\x20as\x20sentiment\x20analysis\x20and\x20entity\n\
    \x20recognition.\n\n\n\n\x03\x06\0\x01\x12\x03\x1c\x08\x17\n<\n\x04\x06\
    \0\x02\0\x12\x04\x1e\x02\x20\x03\x1a.\x20Analyzes\x20the\x20sentiment\
    \x20of\x20the\x20provided\x20text.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\
    \x1e\x06\x16\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x1e\x17.\n\x0c\n\x05\
    \x06\0\x02\0\x03\x12\x03\x1e9Q\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03\x1f\
    \x04T\n\x10\n\t\x06\0\x02\0\x04\xb0\xca\xbc\"\x12\x03\x1f\x04T\n\xb0\x01\
    \n\x04\x06\0\x02\x01\x12\x04%\x02'\x03\x1a\xa1\x01\x20Finds\x20named\x20\
    entities\x20(currently\x20proper\x20names\x20and\x20common\x20nouns)\x20\
    in\x20the\x20text\n\x20along\x20with\x20entity\x20types,\x20salience,\
    \x20mentions\x20for\x20each\x20entity,\x20and\n\x20other\x20properties.\
    \n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03%\x06\x15\n\x0c\n\x05\x06\0\x02\
    \x01\x02\x12\x03%\x16,\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03%7N\n\x0c\n\
    \x05\x06\0\x02\x01\x04\x12\x03&\x04S\n\x10\n\t\x06\0\x02\x01\x04\xb0\xca\
    \xbc\"\x12\x03&\x04S\n\xc9\x01\n\x04\x06\0\x02\x02\x12\x04+\x02-\x03\x1a\
    \xba\x01\x20Finds\x20entities,\x20similar\x20to\x20[AnalyzeEntities][goo\
    gle.cloud.language.v1.LanguageService.AnalyzeEntities]\x20in\x20the\x20t\
    ext\x20and\x20analyzes\n\x20sentiment\x20associated\x20with\x20each\x20e\
    ntity\x20and\x20its\x20mentions.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\
    +\x06\x1c\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03+\x1d:\n\x0c\n\x05\x06\0\
    \x02\x02\x03\x12\x03+Ec\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03,\x04Z\n\
    \x10\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x03,\x04Z\n\xac\x01\n\x04\
    \x06\0\x02\x03\x12\x042\x024\x03\x1a\x9d\x01\x20Analyzes\x20the\x20synta\
    x\x20of\x20the\x20text\x20and\x20provides\x20sentence\x20boundaries\x20a\
    nd\n\x20tokenization\x20along\x20with\x20part\x20of\x20speech\x20tags,\
    \x20dependency\x20trees,\x20and\x20other\n\x20properties.\n\n\x0c\n\x05\
    \x06\0\x02\x03\x01\x12\x032\x06\x13\n\x0c\n\x05\x06\0\x02\x03\x02\x12\
    \x032\x14(\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x0323H\n\x0c\n\x05\x06\0\
    \x02\x03\x04\x12\x033\x04Q\n\x10\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\
    \x033\x04Q\n6\n\x04\x06\0\x02\x04\x12\x047\x029\x03\x1a(\x20Classifies\
    \x20a\x20document\x20into\x20categories.\n\n\x0c\n\x05\x06\0\x02\x04\x01\
    \x12\x037\x06\x12\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x037\x13&\n\x0c\n\
    \x05\x06\0\x02\x04\x03\x12\x0371E\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x038\
    \x04P\n\x10\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\x12\x038\x04P\n\x94\x01\
    \n\x04\x06\0\x02\x05\x12\x04=\x02?\x03\x1a\x85\x01\x20A\x20convenience\
    \x20method\x20that\x20provides\x20all\x20the\x20features\x20that\x20anal\
    yzeSentiment,\n\x20analyzeEntities,\x20and\x20analyzeSyntax\x20provide\
    \x20in\x20one\x20call.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03=\x06\x12\
    \n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03=\x13&\n\x0c\n\x05\x06\0\x02\x05\
    \x03\x12\x03=1E\n\x0c\n\x05\x06\0\x02\x05\x04\x12\x03>\x04P\n\x10\n\t\
    \x06\0\x02\x05\x04\xb0\xca\xbc\"\x12\x03>\x04P\nw\n\x02\x04\0\x12\x04E\0\
    l\x01\x1ak\x20##########################################################\
    ######\x20#\n\n\x20Represents\x20the\x20input\x20to\x20API\x20methods.\n\
    \n\n\n\x03\x04\0\x01\x12\x03E\x08\x10\n(\n\x04\x04\0\x04\0\x12\x04G\x02P\
    \x03\x1a\x1a\x20The\x20document\x20types\x20enum.\n\n\x0c\n\x05\x04\0\
    \x04\0\x01\x12\x03G\x07\x0b\n3\n\x06\x04\0\x04\0\x02\0\x12\x03I\x04\x19\
    \x1a$\x20The\x20content\x20type\x20is\x20not\x20specified.\n\n\x0e\n\x07\
    \x04\0\x04\0\x02\0\x01\x12\x03I\x04\x14\n\x0e\n\x07\x04\0\x04\0\x02\0\
    \x02\x12\x03I\x17\x18\n\x1b\n\x06\x04\0\x04\0\x02\x01\x12\x03L\x04\x13\
    \x1a\x0c\x20Plain\x20text\n\n\x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03L\
    \x04\x0e\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\x03L\x11\x12\n\x15\n\
    \x06\x04\0\x04\0\x02\x02\x12\x03O\x04\r\x1a\x06\x20HTML\n\n\x0e\n\x07\
    \x04\0\x04\0\x02\x02\x01\x12\x03O\x04\x08\n\x0e\n\x07\x04\0\x04\0\x02\
    \x02\x02\x12\x03O\x0b\x0c\no\n\x04\x04\0\x02\0\x12\x03T\x02\x10\x1ab\x20\
    Required.\x20If\x20the\x20type\x20is\x20not\x20set\x20or\x20is\x20`TYPE_\
    UNSPECIFIED`,\n\x20returns\x20an\x20`INVALID_ARGUMENT`\x20error.\n\n\r\n\
    \x05\x04\0\x02\0\x04\x12\x04T\x02P\x03\n\x0c\n\x05\x04\0\x02\0\x06\x12\
    \x03T\x02\x06\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03T\x07\x0b\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03T\x0e\x0f\nk\n\x04\x04\0\x08\0\x12\x04X\x02a\x03\
    \x1a]\x20The\x20source\x20of\x20the\x20document:\x20a\x20string\x20conta\
    ining\x20the\x20content\x20or\x20a\n\x20Google\x20Cloud\x20Storage\x20UR\
    I.\n\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03X\x08\x0e\n9\n\x04\x04\0\x02\x01\
    \x12\x03Z\x04\x17\x1a,\x20The\x20content\x20of\x20the\x20input\x20in\x20\
    string\x20format.\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03Z\x04\n\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03Z\x0b\x12\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03Z\x15\x16\n\x92\x02\n\x04\x04\0\x02\x02\x12\x03`\x04\x1f\x1a\x84\
    \x02\x20The\x20Google\x20Cloud\x20Storage\x20URI\x20where\x20the\x20file\
    \x20content\x20is\x20located.\n\x20This\x20URI\x20must\x20be\x20of\x20th\
    e\x20form:\x20gs://bucket_name/object_name.\x20For\x20more\n\x20details,\
    \x20see\x20https://cloud.google.com/storage/docs/reference-uris.\n\x20NO\
    TE:\x20Cloud\x20Storage\x20object\x20versioning\x20is\x20not\x20supporte\
    d.\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03`\x04\n\n\x0c\n\x05\x04\0\x02\
    \x02\x01\x12\x03`\x0b\x1a\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03`\x1d\x1e\
    \n\xb1\x03\n\x04\x04\0\x02\x03\x12\x03k\x02\x16\x1a\xa3\x03\x20The\x20la\
    nguage\x20of\x20the\x20document\x20(if\x20not\x20specified,\x20the\x20la\
    nguage\x20is\n\x20automatically\x20detected).\x20Both\x20ISO\x20and\x20B\
    CP-47\x20language\x20codes\x20are\n\x20accepted.<br>\n\x20[Language\x20S\
    upport](/natural-language/docs/languages)\n\x20lists\x20currently\x20sup\
    ported\x20languages\x20for\x20each\x20API\x20method.\n\x20If\x20the\x20l\
    anguage\x20(either\x20specified\x20by\x20the\x20caller\x20or\x20automati\
    cally\x20detected)\n\x20is\x20not\x20supported\x20by\x20the\x20called\
    \x20API\x20method,\x20an\x20`INVALID_ARGUMENT`\x20error\n\x20is\x20retur\
    ned.\n\n\r\n\x05\x04\0\x02\x03\x04\x12\x04k\x02a\x03\n\x0c\n\x05\x04\0\
    \x02\x03\x05\x12\x03k\x02\x08\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03k\t\
    \x11\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03k\x14\x15\n:\n\x02\x04\x01\x12\
    \x04o\0w\x01\x1a.\x20Represents\x20a\x20sentence\x20in\x20the\x20input\
    \x20document.\n\n\n\n\x03\x04\x01\x01\x12\x03o\x08\x10\n!\n\x04\x04\x01\
    \x02\0\x12\x03q\x02\x14\x1a\x14\x20The\x20sentence\x20text.\n\n\r\n\x05\
    \x04\x01\x02\0\x04\x12\x04q\x02o\x12\n\x0c\n\x05\x04\x01\x02\0\x06\x12\
    \x03q\x02\n\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03q\x0b\x0f\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03q\x12\x13\n\x8d\x02\n\x04\x04\x01\x02\x01\x12\
    \x03v\x02\x1a\x1a\xff\x01\x20For\x20calls\x20to\x20[AnalyzeSentiment][]\
    \x20or\x20if\n\x20[AnnotateTextRequest.Features.extract_document_sentime\
    nt][google.cloud.language.v1.AnnotateTextRequest.Features.extract_docume\
    nt_sentiment]\x20is\x20set\x20to\n\x20true,\x20this\x20field\x20will\x20\
    contain\x20the\x20sentiment\x20for\x20the\x20sentence.\n\n\r\n\x05\x04\
    \x01\x02\x01\x04\x12\x04v\x02q\x14\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\
    \x03v\x02\x0b\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03v\x0c\x15\n\x0c\n\
    \x05\x04\x01\x02\x01\x03\x12\x03v\x18\x19\n\xc7\x01\n\x02\x04\x02\x12\
    \x05|\0\xb5\x01\x01\x1a\xb9\x01\x20Represents\x20a\x20phrase\x20in\x20th\
    e\x20text\x20that\x20is\x20a\x20known\x20entity,\x20such\x20as\n\x20a\
    \x20person,\x20an\x20organization,\x20or\x20location.\x20The\x20API\x20a\
    ssociates\x20information,\x20such\n\x20as\x20salience\x20and\x20mentions\
    ,\x20with\x20entities.\n\n\n\n\x03\x04\x02\x01\x12\x03|\x08\x0e\n(\n\x04\
    \x04\x02\x04\0\x12\x05~\x02\x96\x01\x03\x1a\x19\x20The\x20type\x20of\x20\
    the\x20entity.\n\n\x0c\n\x05\x04\x02\x04\0\x01\x12\x03~\x07\x0b\n\x19\n\
    \x06\x04\x02\x04\0\x02\0\x12\x04\x80\x01\x04\x10\x1a\t\x20Unknown\n\n\
    \x0f\n\x07\x04\x02\x04\0\x02\0\x01\x12\x04\x80\x01\x04\x0b\n\x0f\n\x07\
    \x04\x02\x04\0\x02\0\x02\x12\x04\x80\x01\x0e\x0f\n\x18\n\x06\x04\x02\x04\
    \0\x02\x01\x12\x04\x83\x01\x04\x0f\x1a\x08\x20Person\n\n\x0f\n\x07\x04\
    \x02\x04\0\x02\x01\x01\x12\x04\x83\x01\x04\n\n\x0f\n\x07\x04\x02\x04\0\
    \x02\x01\x02\x12\x04\x83\x01\r\x0e\n\x1a\n\x06\x04\x02\x04\0\x02\x02\x12\
    \x04\x86\x01\x04\x11\x1a\n\x20Location\n\n\x0f\n\x07\x04\x02\x04\0\x02\
    \x02\x01\x12\x04\x86\x01\x04\x0c\n\x0f\n\x07\x04\x02\x04\0\x02\x02\x02\
    \x12\x04\x86\x01\x0f\x10\n\x1e\n\x06\x04\x02\x04\0\x02\x03\x12\x04\x89\
    \x01\x04\x15\x1a\x0e\x20Organization\n\n\x0f\n\x07\x04\x02\x04\0\x02\x03\
    \x01\x12\x04\x89\x01\x04\x10\n\x0f\n\x07\x04\x02\x04\0\x02\x03\x02\x12\
    \x04\x89\x01\x13\x14\n\x17\n\x06\x04\x02\x04\0\x02\x04\x12\x04\x8c\x01\
    \x04\x0e\x1a\x07\x20Event\n\n\x0f\n\x07\x04\x02\x04\0\x02\x04\x01\x12\
    \x04\x8c\x01\x04\t\n\x0f\n\x07\x04\x02\x04\0\x02\x04\x02\x12\x04\x8c\x01\
    \x0c\r\n\x1d\n\x06\x04\x02\x04\0\x02\x05\x12\x04\x8f\x01\x04\x14\x1a\r\
    \x20Work\x20of\x20art\n\n\x0f\n\x07\x04\x02\x04\0\x02\x05\x01\x12\x04\
    \x8f\x01\x04\x0f\n\x0f\n\x07\x04\x02\x04\0\x02\x05\x02\x12\x04\x8f\x01\
    \x12\x13\n\x20\n\x06\x04\x02\x04\0\x02\x06\x12\x04\x92\x01\x04\x16\x1a\
    \x10\x20Consumer\x20goods\n\n\x0f\n\x07\x04\x02\x04\0\x02\x06\x01\x12\
    \x04\x92\x01\x04\x11\n\x0f\n\x07\x04\x02\x04\0\x02\x06\x02\x12\x04\x92\
    \x01\x14\x15\n\x1d\n\x06\x04\x02\x04\0\x02\x07\x12\x04\x95\x01\x04\x0e\
    \x1a\r\x20Other\x20types\n\n\x0f\n\x07\x04\x02\x04\0\x02\x07\x01\x12\x04\
    \x95\x01\x04\t\n\x0f\n\x07\x04\x02\x04\0\x02\x07\x02\x12\x04\x95\x01\x0c\
    \r\n7\n\x04\x04\x02\x02\0\x12\x04\x99\x01\x02\x12\x1a)\x20The\x20represe\
    ntative\x20name\x20for\x20the\x20entity.\n\n\x0f\n\x05\x04\x02\x02\0\x04\
    \x12\x06\x99\x01\x02\x96\x01\x03\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\x99\
    \x01\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\x99\x01\t\r\n\r\n\x05\
    \x04\x02\x02\0\x03\x12\x04\x99\x01\x10\x11\n\x20\n\x04\x04\x02\x02\x01\
    \x12\x04\x9c\x01\x02\x10\x1a\x12\x20The\x20entity\x20type.\n\n\x0f\n\x05\
    \x04\x02\x02\x01\x04\x12\x06\x9c\x01\x02\x99\x01\x12\n\r\n\x05\x04\x02\
    \x02\x01\x06\x12\x04\x9c\x01\x02\x06\n\r\n\x05\x04\x02\x02\x01\x01\x12\
    \x04\x9c\x01\x07\x0b\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\x9c\x01\x0e\
    \x0f\n\xc8\x01\n\x04\x04\x02\x02\x02\x12\x04\xa2\x01\x02#\x1a\xb9\x01\
    \x20Metadata\x20associated\x20with\x20the\x20entity.\n\n\x20Currently,\
    \x20Wikipedia\x20URLs\x20and\x20Knowledge\x20Graph\x20MIDs\x20are\x20pro\
    vided,\x20if\n\x20available.\x20The\x20associated\x20keys\x20are\x20\"wi\
    kipedia_url\"\x20and\x20\"mid\",\x20respectively.\n\n\x0f\n\x05\x04\x02\
    \x02\x02\x04\x12\x06\xa2\x01\x02\x9c\x01\x10\n\r\n\x05\x04\x02\x02\x02\
    \x06\x12\x04\xa2\x01\x02\x15\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xa2\
    \x01\x16\x1e\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xa2\x01!\"\n\xb3\x02\
    \n\x04\x04\x02\x02\x03\x12\x04\xaa\x01\x02\x15\x1a\xa4\x02\x20The\x20sal\
    ience\x20score\x20associated\x20with\x20the\x20entity\x20in\x20the\x20[0\
    ,\x201.0]\x20range.\n\n\x20The\x20salience\x20score\x20for\x20an\x20enti\
    ty\x20provides\x20information\x20about\x20the\n\x20importance\x20or\x20c\
    entrality\x20of\x20that\x20entity\x20to\x20the\x20entire\x20document\x20\
    text.\n\x20Scores\x20closer\x20to\x200\x20are\x20less\x20salient,\x20whi\
    le\x20scores\x20closer\x20to\x201.0\x20are\x20highly\n\x20salient.\n\n\
    \x0f\n\x05\x04\x02\x02\x03\x04\x12\x06\xaa\x01\x02\xa2\x01#\n\r\n\x05\
    \x04\x02\x02\x03\x05\x12\x04\xaa\x01\x02\x07\n\r\n\x05\x04\x02\x02\x03\
    \x01\x12\x04\xaa\x01\x08\x10\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\xaa\
    \x01\x13\x14\nt\n\x04\x04\x02\x02\x04\x12\x04\xae\x01\x02&\x1af\x20The\
    \x20mentions\x20of\x20this\x20entity\x20in\x20the\x20input\x20document.\
    \x20The\x20API\x20currently\n\x20supports\x20proper\x20noun\x20mentions.\
    \n\n\r\n\x05\x04\x02\x02\x04\x04\x12\x04\xae\x01\x02\n\n\r\n\x05\x04\x02\
    \x02\x04\x06\x12\x04\xae\x01\x0b\x18\n\r\n\x05\x04\x02\x02\x04\x01\x12\
    \x04\xae\x01\x19!\n\r\n\x05\x04\x02\x02\x04\x03\x12\x04\xae\x01$%\n\xbd\
    \x02\n\x04\x04\x02\x02\x05\x12\x04\xb4\x01\x02\x1a\x1a\xae\x02\x20For\
    \x20calls\x20to\x20[AnalyzeEntitySentiment][]\x20or\x20if\n\x20[Annotate\
    TextRequest.Features.extract_entity_sentiment][google.cloud.language.v1.\
    AnnotateTextRequest.Features.extract_entity_sentiment]\x20is\x20set\x20t\
    o\n\x20true,\x20this\x20field\x20will\x20contain\x20the\x20aggregate\x20\
    sentiment\x20expressed\x20for\x20this\n\x20entity\x20in\x20the\x20provid\
    ed\x20document.\n\n\x0f\n\x05\x04\x02\x02\x05\x04\x12\x06\xb4\x01\x02\
    \xae\x01&\n\r\n\x05\x04\x02\x02\x05\x06\x12\x04\xb4\x01\x02\x0b\n\r\n\
    \x05\x04\x02\x02\x05\x01\x12\x04\xb4\x01\x0c\x15\n\r\n\x05\x04\x02\x02\
    \x05\x03\x12\x04\xb4\x01\x18\x19\nM\n\x02\x04\x03\x12\x06\xb8\x01\0\xc4\
    \x01\x01\x1a?\x20Represents\x20the\x20smallest\x20syntactic\x20building\
    \x20block\x20of\x20the\x20text.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xb8\
    \x01\x08\r\n\x1f\n\x04\x04\x03\x02\0\x12\x04\xba\x01\x02\x14\x1a\x11\x20\
    The\x20token\x20text.\n\n\x0f\n\x05\x04\x03\x02\0\x04\x12\x06\xba\x01\
    \x02\xb8\x01\x0f\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\xba\x01\x02\n\n\r\n\
    \x05\x04\x03\x02\0\x01\x12\x04\xba\x01\x0b\x0f\n\r\n\x05\x04\x03\x02\0\
    \x03\x12\x04\xba\x01\x12\x13\n3\n\x04\x04\x03\x02\x01\x12\x04\xbd\x01\
    \x02\"\x1a%\x20Parts\x20of\x20speech\x20tag\x20for\x20this\x20token.\n\n\
    \x0f\n\x05\x04\x03\x02\x01\x04\x12\x06\xbd\x01\x02\xba\x01\x14\n\r\n\x05\
    \x04\x03\x02\x01\x06\x12\x04\xbd\x01\x02\x0e\n\r\n\x05\x04\x03\x02\x01\
    \x01\x12\x04\xbd\x01\x0f\x1d\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xbd\
    \x01\x20!\n5\n\x04\x04\x03\x02\x02\x12\x04\xc0\x01\x02%\x1a'\x20Dependen\
    cy\x20tree\x20parse\x20for\x20this\x20token.\n\n\x0f\n\x05\x04\x03\x02\
    \x02\x04\x12\x06\xc0\x01\x02\xbd\x01\"\n\r\n\x05\x04\x03\x02\x02\x06\x12\
    \x04\xc0\x01\x02\x10\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xc0\x01\x11\
    \x20\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\xc0\x01#$\n[\n\x04\x04\x03\
    \x02\x03\x12\x04\xc3\x01\x02\x13\x1aM\x20[Lemma](https://en.wikipedia.or\
    g/wiki/Lemma_%28morphology%29)\x20of\x20the\x20token.\n\n\x0f\n\x05\x04\
    \x03\x02\x03\x04\x12\x06\xc3\x01\x02\xc0\x01%\n\r\n\x05\x04\x03\x02\x03\
    \x05\x12\x04\xc3\x01\x02\x08\n\r\n\x05\x04\x03\x02\x03\x01\x12\x04\xc3\
    \x01\t\x0e\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xc3\x01\x11\x12\n`\n\
    \x02\x04\x04\x12\x06\xc8\x01\0\xd1\x01\x01\x1aR\x20Represents\x20the\x20\
    feeling\x20associated\x20with\x20the\x20entire\x20text\x20or\x20entities\
    \x20in\n\x20the\x20text.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xc8\x01\x08\
    \x11\n\xa1\x01\n\x04\x04\x04\x02\0\x12\x04\xcc\x01\x02\x16\x1a\x92\x01\
    \x20A\x20non-negative\x20number\x20in\x20the\x20[0,\x20+inf)\x20range,\
    \x20which\x20represents\n\x20the\x20absolute\x20magnitude\x20of\x20senti\
    ment\x20regardless\x20of\x20score\x20(positive\x20or\n\x20negative).\n\n\
    \x0f\n\x05\x04\x04\x02\0\x04\x12\x06\xcc\x01\x02\xc8\x01\x13\n\r\n\x05\
    \x04\x04\x02\0\x05\x12\x04\xcc\x01\x02\x07\n\r\n\x05\x04\x04\x02\0\x01\
    \x12\x04\xcc\x01\x08\x11\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xcc\x01\x14\
    \x15\n`\n\x04\x04\x04\x02\x01\x12\x04\xd0\x01\x02\x12\x1aR\x20Sentiment\
    \x20score\x20between\x20-1.0\x20(negative\x20sentiment)\x20and\x201.0\n\
    \x20(positive\x20sentiment).\n\n\x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\
    \xd0\x01\x02\xcc\x01\x16\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xd0\x01\
    \x02\x07\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\xd0\x01\x08\r\n\r\n\x05\
    \x04\x04\x02\x01\x03\x12\x04\xd0\x01\x10\x11\n\xa7\x01\n\x02\x04\x05\x12\
    \x06\xd6\x01\0\x9b\x04\x01\x1a\x98\x01\x20Represents\x20part\x20of\x20sp\
    eech\x20information\x20for\x20a\x20token.\x20Parts\x20of\x20speech\n\x20\
    are\x20as\x20defined\x20in\n\x20http://www.lrec-conf.org/proceedings/lre\
    c2012/pdf/274_Paper.pdf\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xd6\x01\x08\
    \x14\n/\n\x04\x04\x05\x04\0\x12\x06\xd8\x01\x02\x82\x02\x03\x1a\x1f\x20T\
    he\x20part\x20of\x20speech\x20tags\x20enum.\n\n\r\n\x05\x04\x05\x04\0\
    \x01\x12\x04\xd8\x01\x07\n\n\x19\n\x06\x04\x05\x04\0\x02\0\x12\x04\xda\
    \x01\x04\x10\x1a\t\x20Unknown\n\n\x0f\n\x07\x04\x05\x04\0\x02\0\x01\x12\
    \x04\xda\x01\x04\x0b\n\x0f\n\x07\x04\x05\x04\0\x02\0\x02\x12\x04\xda\x01\
    \x0e\x0f\n\x1b\n\x06\x04\x05\x04\0\x02\x01\x12\x04\xdd\x01\x04\x0c\x1a\
    \x0b\x20Adjective\n\n\x0f\n\x07\x04\x05\x04\0\x02\x01\x01\x12\x04\xdd\
    \x01\x04\x07\n\x0f\n\x07\x04\x05\x04\0\x02\x01\x02\x12\x04\xdd\x01\n\x0b\
    \n;\n\x06\x04\x05\x04\0\x02\x02\x12\x04\xe0\x01\x04\x0c\x1a+\x20Adpositi\
    on\x20(preposition\x20and\x20postposition)\n\n\x0f\n\x07\x04\x05\x04\0\
    \x02\x02\x01\x12\x04\xe0\x01\x04\x07\n\x0f\n\x07\x04\x05\x04\0\x02\x02\
    \x02\x12\x04\xe0\x01\n\x0b\n\x18\n\x06\x04\x05\x04\0\x02\x03\x12\x04\xe3\
    \x01\x04\x0c\x1a\x08\x20Adverb\n\n\x0f\n\x07\x04\x05\x04\0\x02\x03\x01\
    \x12\x04\xe3\x01\x04\x07\n\x0f\n\x07\x04\x05\x04\0\x02\x03\x02\x12\x04\
    \xe3\x01\n\x0b\n\x1d\n\x06\x04\x05\x04\0\x02\x04\x12\x04\xe6\x01\x04\r\
    \x1a\r\x20Conjunction\n\n\x0f\n\x07\x04\x05\x04\0\x02\x04\x01\x12\x04\
    \xe6\x01\x04\x08\n\x0f\n\x07\x04\x05\x04\0\x02\x04\x02\x12\x04\xe6\x01\
    \x0b\x0c\n\x1c\n\x06\x04\x05\x04\0\x02\x05\x12\x04\xe9\x01\x04\x0c\x1a\
    \x0c\x20Determiner\n\n\x0f\n\x07\x04\x05\x04\0\x02\x05\x01\x12\x04\xe9\
    \x01\x04\x07\n\x0f\n\x07\x04\x05\x04\0\x02\x05\x02\x12\x04\xe9\x01\n\x0b\
    \n*\n\x06\x04\x05\x04\0\x02\x06\x12\x04\xec\x01\x04\r\x1a\x1a\x20Noun\
    \x20(common\x20and\x20proper)\n\n\x0f\n\x07\x04\x05\x04\0\x02\x06\x01\
    \x12\x04\xec\x01\x04\x08\n\x0f\n\x07\x04\x05\x04\0\x02\x06\x02\x12\x04\
    \xec\x01\x0b\x0c\n!\n\x06\x04\x05\x04\0\x02\x07\x12\x04\xef\x01\x04\x0c\
    \x1a\x11\x20Cardinal\x20number\n\n\x0f\n\x07\x04\x05\x04\0\x02\x07\x01\
    \x12\x04\xef\x01\x04\x07\n\x0f\n\x07\x04\x05\x04\0\x02\x07\x02\x12\x04\
    \xef\x01\n\x0b\n\x19\n\x06\x04\x05\x04\0\x02\x08\x12\x04\xf2\x01\x04\r\
    \x1a\t\x20Pronoun\n\n\x0f\n\x07\x04\x05\x04\0\x02\x08\x01\x12\x04\xf2\
    \x01\x04\x08\n\x0f\n\x07\x04\x05\x04\0\x02\x08\x02\x12\x04\xf2\x01\x0b\
    \x0c\n1\n\x06\x04\x05\x04\0\x02\t\x12\x04\xf5\x01\x04\x0c\x1a!\x20Partic\
    le\x20or\x20other\x20function\x20word\n\n\x0f\n\x07\x04\x05\x04\0\x02\t\
    \x01\x12\x04\xf5\x01\x04\x07\n\x0f\n\x07\x04\x05\x04\0\x02\t\x02\x12\x04\
    \xf5\x01\n\x0b\n\x1d\n\x06\x04\x05\x04\0\x02\n\x12\x04\xf8\x01\x04\x0f\
    \x1a\r\x20Punctuation\n\n\x0f\n\x07\x04\x05\x04\0\x02\n\x01\x12\x04\xf8\
    \x01\x04\t\n\x0f\n\x07\x04\x05\x04\0\x02\n\x02\x12\x04\xf8\x01\x0c\x0e\n\
    -\n\x06\x04\x05\x04\0\x02\x0b\x12\x04\xfb\x01\x04\x0e\x1a\x1d\x20Verb\
    \x20(all\x20tenses\x20and\x20modes)\n\n\x0f\n\x07\x04\x05\x04\0\x02\x0b\
    \x01\x12\x04\xfb\x01\x04\x08\n\x0f\n\x07\x04\x05\x04\0\x02\x0b\x02\x12\
    \x04\xfb\x01\x0b\r\n<\n\x06\x04\x05\x04\0\x02\x0c\x12\x04\xfe\x01\x04\
    \x0b\x1a,\x20Other:\x20foreign\x20words,\x20typos,\x20abbreviations\n\n\
    \x0f\n\x07\x04\x05\x04\0\x02\x0c\x01\x12\x04\xfe\x01\x04\x05\n\x0f\n\x07\
    \x04\x05\x04\0\x02\x0c\x02\x12\x04\xfe\x01\x08\n\n\x17\n\x06\x04\x05\x04\
    \0\x02\r\x12\x04\x81\x02\x04\x0f\x1a\x07\x20Affix\n\n\x0f\n\x07\x04\x05\
    \x04\0\x02\r\x01\x12\x04\x81\x02\x04\t\n\x0f\n\x07\x04\x05\x04\0\x02\r\
    \x02\x12\x04\x81\x02\x0c\x0e\nX\n\x04\x04\x05\x04\x01\x12\x06\x85\x02\
    \x02\x91\x02\x03\x1aH\x20The\x20characteristic\x20of\x20a\x20verb\x20tha\
    t\x20expresses\x20time\x20flow\x20during\x20an\x20event.\n\n\r\n\x05\x04\
    \x05\x04\x01\x01\x12\x04\x85\x02\x07\r\nX\n\x06\x04\x05\x04\x01\x02\0\
    \x12\x04\x87\x02\x04\x17\x1aH\x20Aspect\x20is\x20not\x20applicable\x20in\
    \x20the\x20analyzed\x20language\x20or\x20is\x20not\x20predicted.\n\n\x0f\
    \n\x07\x04\x05\x04\x01\x02\0\x01\x12\x04\x87\x02\x04\x12\n\x0f\n\x07\x04\
    \x05\x04\x01\x02\0\x02\x12\x04\x87\x02\x15\x16\n\x1c\n\x06\x04\x05\x04\
    \x01\x02\x01\x12\x04\x8a\x02\x04\x13\x1a\x0c\x20Perfective\n\n\x0f\n\x07\
    \x04\x05\x04\x01\x02\x01\x01\x12\x04\x8a\x02\x04\x0e\n\x0f\n\x07\x04\x05\
    \x04\x01\x02\x01\x02\x12\x04\x8a\x02\x11\x12\n\x1e\n\x06\x04\x05\x04\x01\
    \x02\x02\x12\x04\x8d\x02\x04\x15\x1a\x0e\x20Imperfective\n\n\x0f\n\x07\
    \x04\x05\x04\x01\x02\x02\x01\x12\x04\x8d\x02\x04\x10\n\x0f\n\x07\x04\x05\
    \x04\x01\x02\x02\x02\x12\x04\x8d\x02\x13\x14\n\x1d\n\x06\x04\x05\x04\x01\
    \x02\x03\x12\x04\x90\x02\x04\x14\x1a\r\x20Progressive\n\n\x0f\n\x07\x04\
    \x05\x04\x01\x02\x03\x01\x12\x04\x90\x02\x04\x0f\n\x0f\n\x07\x04\x05\x04\
    \x01\x02\x03\x02\x12\x04\x90\x02\x12\x13\n\xeb\x01\n\x04\x04\x05\x04\x02\
    \x12\x06\x96\x02\x02\xc3\x02\x03\x1a\xda\x01\x20The\x20grammatical\x20fu\
    nction\x20performed\x20by\x20a\x20noun\x20or\x20pronoun\x20in\x20a\x20ph\
    rase,\n\x20clause,\x20or\x20sentence.\x20In\x20some\x20languages,\x20oth\
    er\x20parts\x20of\x20speech,\x20such\x20as\n\x20adjective\x20and\x20dete\
    rminer,\x20take\x20case\x20inflection\x20in\x20agreement\x20with\x20the\
    \x20noun.\n\n\r\n\x05\x04\x05\x04\x02\x01\x12\x04\x96\x02\x07\x0b\nV\n\
    \x06\x04\x05\x04\x02\x02\0\x12\x04\x98\x02\x04\x15\x1aF\x20Case\x20is\
    \x20not\x20applicable\x20in\x20the\x20analyzed\x20language\x20or\x20is\
    \x20not\x20predicted.\n\n\x0f\n\x07\x04\x05\x04\x02\x02\0\x01\x12\x04\
    \x98\x02\x04\x10\n\x0f\n\x07\x04\x05\x04\x02\x02\0\x02\x12\x04\x98\x02\
    \x13\x14\n\x1c\n\x06\x04\x05\x04\x02\x02\x01\x12\x04\x9b\x02\x04\x13\x1a\
    \x0c\x20Accusative\n\n\x0f\n\x07\x04\x05\x04\x02\x02\x01\x01\x12\x04\x9b\
    \x02\x04\x0e\n\x0f\n\x07\x04\x05\x04\x02\x02\x01\x02\x12\x04\x9b\x02\x11\
    \x12\n\x1b\n\x06\x04\x05\x04\x02\x02\x02\x12\x04\x9e\x02\x04\x12\x1a\x0b\
    \x20Adverbial\n\n\x0f\n\x07\x04\x05\x04\x02\x02\x02\x01\x12\x04\x9e\x02\
    \x04\r\n\x0f\n\x07\x04\x05\x04\x02\x02\x02\x02\x12\x04\x9e\x02\x10\x11\n\
    \x1f\n\x06\x04\x05\x04\x02\x02\x03\x12\x04\xa1\x02\x04\x16\x1a\x0f\x20Co\
    mplementive\n\n\x0f\n\x07\x04\x05\x04\x02\x02\x03\x01\x12\x04\xa1\x02\
    \x04\x11\n\x0f\n\x07\x04\x05\x04\x02\x02\x03\x02\x12\x04\xa1\x02\x14\x15\
    \n\x18\n\x06\x04\x05\x04\x02\x02\x04\x12\x04\xa4\x02\x04\x0f\x1a\x08\x20\
    Dative\n\n\x0f\n\x07\x04\x05\x04\x02\x02\x04\x01\x12\x04\xa4\x02\x04\n\n\
    \x0f\n\x07\x04\x05\x04\x02\x02\x04\x02\x12\x04\xa4\x02\r\x0e\n\x1a\n\x06\
    \x04\x05\x04\x02\x02\x05\x12\x04\xa7\x02\x04\x11\x1a\n\x20Genitive\n\n\
    \x0f\n\x07\x04\x05\x04\x02\x02\x05\x01\x12\x04\xa7\x02\x04\x0c\n\x0f\n\
    \x07\x04\x05\x04\x02\x02\x05\x02\x12\x04\xa7\x02\x0f\x10\n\x1e\n\x06\x04\
    \x05\x04\x02\x02\x06\x12\x04\xaa\x02\x04\x15\x1a\x0e\x20Instrumental\n\n\
    \x0f\n\x07\x04\x05\x04\x02\x02\x06\x01\x12\x04\xaa\x02\x04\x10\n\x0f\n\
    \x07\x04\x05\x04\x02\x02\x06\x02\x12\x04\xaa\x02\x13\x14\n\x1a\n\x06\x04\
    \x05\x04\x02\x02\x07\x12\x04\xad\x02\x04\x11\x1a\n\x20Locative\n\n\x0f\n\
    \x07\x04\x05\x04\x02\x02\x07\x01\x12\x04\xad\x02\x04\x0c\n\x0f\n\x07\x04\
    \x05\x04\x02\x02\x07\x02\x12\x04\xad\x02\x0f\x10\n\x1c\n\x06\x04\x05\x04\
    \x02\x02\x08\x12\x04\xb0\x02\x04\x13\x1a\x0c\x20Nominative\n\n\x0f\n\x07\
    \x04\x05\x04\x02\x02\x08\x01\x12\x04\xb0\x02\x04\x0e\n\x0f\n\x07\x04\x05\
    \x04\x02\x02\x08\x02\x12\x04\xb0\x02\x11\x12\n\x19\n\x06\x04\x05\x04\x02\
    \x02\t\x12\x04\xb3\x02\x04\x10\x1a\t\x20Oblique\n\n\x0f\n\x07\x04\x05\
    \x04\x02\x02\t\x01\x12\x04\xb3\x02\x04\x0b\n\x0f\n\x07\x04\x05\x04\x02\
    \x02\t\x02\x12\x04\xb3\x02\x0e\x0f\n\x1b\n\x06\x04\x05\x04\x02\x02\n\x12\
    \x04\xb6\x02\x04\x13\x1a\x0b\x20Partitive\n\n\x0f\n\x07\x04\x05\x04\x02\
    \x02\n\x01\x12\x04\xb6\x02\x04\r\n\x0f\n\x07\x04\x05\x04\x02\x02\n\x02\
    \x12\x04\xb6\x02\x10\x12\n\x1f\n\x06\x04\x05\x04\x02\x02\x0b\x12\x04\xb9\
    \x02\x04\x17\x1a\x0f\x20Prepositional\n\n\x0f\n\x07\x04\x05\x04\x02\x02\
    \x0b\x01\x12\x04\xb9\x02\x04\x11\n\x0f\n\x07\x04\x05\x04\x02\x02\x0b\x02\
    \x12\x04\xb9\x02\x14\x16\n\x1b\n\x06\x04\x05\x04\x02\x02\x0c\x12\x04\xbc\
    \x02\x04\x18\x1a\x0b\x20Reflexive\n\n\x0f\n\x07\x04\x05\x04\x02\x02\x0c\
    \x01\x12\x04\xbc\x02\x04\x12\n\x0f\n\x07\x04\x05\x04\x02\x02\x0c\x02\x12\
    \x04\xbc\x02\x15\x17\n\x1a\n\x06\x04\x05\x04\x02\x02\r\x12\x04\xbf\x02\
    \x04\x17\x1a\n\x20Relative\n\n\x0f\n\x07\x04\x05\x04\x02\x02\r\x01\x12\
    \x04\xbf\x02\x04\x11\n\x0f\n\x07\x04\x05\x04\x02\x02\r\x02\x12\x04\xbf\
    \x02\x14\x16\n\x1a\n\x06\x04\x05\x04\x02\x02\x0e\x12\x04\xc2\x02\x04\x12\
    \x1a\n\x20Vocative\n\n\x0f\n\x07\x04\x05\x04\x02\x02\x0e\x01\x12\x04\xc2\
    \x02\x04\x0c\n\x0f\n\x07\x04\x05\x04\x02\x02\x0e\x02\x12\x04\xc2\x02\x0f\
    \x11\n\x8e\x02\n\x04\x04\x05\x04\x03\x12\x06\xc9\x02\x02\xed\x02\x03\x1a\
    \xfd\x01\x20Depending\x20on\x20the\x20language,\x20Form\x20can\x20be\x20\
    categorizing\x20different\x20forms\x20of\n\x20verbs,\x20adjectives,\x20a\
    dverbs,\x20etc.\x20For\x20example,\x20categorizing\x20inflected\n\x20end\
    ings\x20of\x20verbs\x20and\x20adjectives\x20or\x20distinguishing\x20betw\
    een\x20short\x20and\x20long\n\x20forms\x20of\x20adjectives\x20and\x20par\
    ticiples\n\n\r\n\x05\x04\x05\x04\x03\x01\x12\x04\xc9\x02\x07\x0b\nV\n\
    \x06\x04\x05\x04\x03\x02\0\x12\x04\xcb\x02\x04\x15\x1aF\x20Form\x20is\
    \x20not\x20applicable\x20in\x20the\x20analyzed\x20language\x20or\x20is\
    \x20not\x20predicted.\n\n\x0f\n\x07\x04\x05\x04\x03\x02\0\x01\x12\x04\
    \xcb\x02\x04\x10\n\x0f\n\x07\x04\x05\x04\x03\x02\0\x02\x12\x04\xcb\x02\
    \x13\x14\n\x1a\n\x06\x04\x05\x04\x03\x02\x01\x12\x04\xce\x02\x04\x11\x1a\
    \n\x20Adnomial\n\n\x0f\n\x07\x04\x05\x04\x03\x02\x01\x01\x12\x04\xce\x02\
    \x04\x0c\n\x0f\n\x07\x04\x05\x04\x03\x02\x01\x02\x12\x04\xce\x02\x0f\x10\
    \n\x1b\n\x06\x04\x05\x04\x03\x02\x02\x12\x04\xd1\x02\x04\x12\x1a\x0b\x20\
    Auxiliary\n\n\x0f\n\x07\x04\x05\x04\x03\x02\x02\x01\x12\x04\xd1\x02\x04\
    \r\n\x0f\n\x07\x04\x05\x04\x03\x02\x02\x02\x12\x04\xd1\x02\x10\x11\n\x20\
    \n\x06\x04\x05\x04\x03\x02\x03\x12\x04\xd4\x02\x04\x17\x1a\x10\x20Comple\
    mentizer\n\n\x0f\n\x07\x04\x05\x04\x03\x02\x03\x01\x12\x04\xd4\x02\x04\
    \x12\n\x0f\n\x07\x04\x05\x04\x03\x02\x03\x02\x12\x04\xd4\x02\x15\x16\n\
    \x1e\n\x06\x04\x05\x04\x03\x02\x04\x12\x04\xd7\x02\x04\x15\x1a\x0e\x20Fi\
    nal\x20ending\n\n\x0f\n\x07\x04\x05\x04\x03\x02\x04\x01\x12\x04\xd7\x02\
    \x04\x10\n\x0f\n\x07\x04\x05\x04\x03\x02\x04\x02\x12\x04\xd7\x02\x13\x14\
    \n\x18\n\x06\x04\x05\x04\x03\x02\x05\x12\x04\xda\x02\x04\x0f\x1a\x08\x20\
    Gerund\n\n\x0f\n\x07\x04\x05\x04\x03\x02\x05\x01\x12\x04\xda\x02\x04\n\n\
    \x0f\n\x07\x04\x05\x04\x03\x02\x05\x02\x12\x04\xda\x02\r\x0e\n\x18\n\x06\
    \x04\x05\x04\x03\x02\x06\x12\x04\xdd\x02\x04\x0f\x1a\x08\x20Realis\n\n\
    \x0f\n\x07\x04\x05\x04\x03\x02\x06\x01\x12\x04\xdd\x02\x04\n\n\x0f\n\x07\
    \x04\x05\x04\x03\x02\x06\x02\x12\x04\xdd\x02\r\x0e\n\x1a\n\x06\x04\x05\
    \x04\x03\x02\x07\x12\x04\xe0\x02\x04\x11\x1a\n\x20Irrealis\n\n\x0f\n\x07\
    \x04\x05\x04\x03\x02\x07\x01\x12\x04\xe0\x02\x04\x0c\n\x0f\n\x07\x04\x05\
    \x04\x03\x02\x07\x02\x12\x04\xe0\x02\x0f\x10\n\x1c\n\x06\x04\x05\x04\x03\
    \x02\x08\x12\x04\xe3\x02\x04\x0e\x1a\x0c\x20Short\x20form\n\n\x0f\n\x07\
    \x04\x05\x04\x03\x02\x08\x01\x12\x04\xe3\x02\x04\t\n\x0f\n\x07\x04\x05\
    \x04\x03\x02\x08\x02\x12\x04\xe3\x02\x0c\r\n\x1b\n\x06\x04\x05\x04\x03\
    \x02\t\x12\x04\xe6\x02\x04\r\x1a\x0b\x20Long\x20form\n\n\x0f\n\x07\x04\
    \x05\x04\x03\x02\t\x01\x12\x04\xe6\x02\x04\x08\n\x0f\n\x07\x04\x05\x04\
    \x03\x02\t\x02\x12\x04\xe6\x02\x0b\x0c\n\x1c\n\x06\x04\x05\x04\x03\x02\n\
    \x12\x04\xe9\x02\x04\x0f\x1a\x0c\x20Order\x20form\n\n\x0f\n\x07\x04\x05\
    \x04\x03\x02\n\x01\x12\x04\xe9\x02\x04\t\n\x0f\n\x07\x04\x05\x04\x03\x02\
    \n\x02\x12\x04\xe9\x02\x0c\x0e\n\x1f\n\x06\x04\x05\x04\x03\x02\x0b\x12\
    \x04\xec\x02\x04\x12\x1a\x0f\x20Specific\x20form\n\n\x0f\n\x07\x04\x05\
    \x04\x03\x02\x0b\x01\x12\x04\xec\x02\x04\x0c\n\x0f\n\x07\x04\x05\x04\x03\
    \x02\x0b\x02\x12\x04\xec\x02\x0f\x11\nY\n\x04\x04\x05\x04\x04\x12\x06\
    \xf0\x02\x02\xfc\x02\x03\x1aI\x20Gender\x20classes\x20of\x20nouns\x20ref\
    lected\x20in\x20the\x20behaviour\x20of\x20associated\x20words.\n\n\r\n\
    \x05\x04\x05\x04\x04\x01\x12\x04\xf0\x02\x07\r\nX\n\x06\x04\x05\x04\x04\
    \x02\0\x12\x04\xf2\x02\x04\x17\x1aH\x20Gender\x20is\x20not\x20applicable\
    \x20in\x20the\x20analyzed\x20language\x20or\x20is\x20not\x20predicted.\n\
    \n\x0f\n\x07\x04\x05\x04\x04\x02\0\x01\x12\x04\xf2\x02\x04\x12\n\x0f\n\
    \x07\x04\x05\x04\x04\x02\0\x02\x12\x04\xf2\x02\x15\x16\n\x1a\n\x06\x04\
    \x05\x04\x04\x02\x01\x12\x04\xf5\x02\x04\x11\x1a\n\x20Feminine\n\n\x0f\n\
    \x07\x04\x05\x04\x04\x02\x01\x01\x12\x04\xf5\x02\x04\x0c\n\x0f\n\x07\x04\
    \x05\x04\x04\x02\x01\x02\x12\x04\xf5\x02\x0f\x10\n\x1b\n\x06\x04\x05\x04\
    \x04\x02\x02\x12\x04\xf8\x02\x04\x12\x1a\x0b\x20Masculine\n\n\x0f\n\x07\
    \x04\x05\x04\x04\x02\x02\x01\x12\x04\xf8\x02\x04\r\n\x0f\n\x07\x04\x05\
    \x04\x04\x02\x02\x02\x12\x04\xf8\x02\x10\x11\n\x18\n\x06\x04\x05\x04\x04\
    \x02\x03\x12\x04\xfb\x02\x04\x0f\x1a\x08\x20Neuter\n\n\x0f\n\x07\x04\x05\
    \x04\x04\x02\x03\x01\x12\x04\xfb\x02\x04\n\n\x0f\n\x07\x04\x05\x04\x04\
    \x02\x03\x02\x12\x04\xfb\x02\r\x0e\n[\n\x04\x04\x05\x04\x05\x12\x06\xff\
    \x02\x02\x94\x03\x03\x1aK\x20The\x20grammatical\x20feature\x20of\x20verb\
    s,\x20used\x20for\x20showing\x20modality\x20and\x20attitude.\n\n\r\n\x05\
    \x04\x05\x04\x05\x01\x12\x04\xff\x02\x07\x0b\nV\n\x06\x04\x05\x04\x05\
    \x02\0\x12\x04\x81\x03\x04\x15\x1aF\x20Mood\x20is\x20not\x20applicable\
    \x20in\x20the\x20analyzed\x20language\x20or\x20is\x20not\x20predicted.\n\
    \n\x0f\n\x07\x04\x05\x04\x05\x02\0\x01\x12\x04\x81\x03\x04\x10\n\x0f\n\
    \x07\x04\x05\x04\x05\x02\0\x02\x12\x04\x81\x03\x13\x14\n\x1d\n\x06\x04\
    \x05\x04\x05\x02\x01\x12\x04\x84\x03\x04\x19\x1a\r\x20Conditional\n\n\
    \x0f\n\x07\x04\x05\x04\x05\x02\x01\x01\x12\x04\x84\x03\x04\x14\n\x0f\n\
    \x07\x04\x05\x04\x05\x02\x01\x02\x12\x04\x84\x03\x17\x18\n\x1c\n\x06\x04\
    \x05\x04\x05\x02\x02\x12\x04\x87\x03\x04\x13\x1a\x0c\x20Imperative\n\n\
    \x0f\n\x07\x04\x05\x04\x05\x02\x02\x01\x12\x04\x87\x03\x04\x0e\n\x0f\n\
    \x07\x04\x05\x04\x05\x02\x02\x02\x12\x04\x87\x03\x11\x12\n\x1c\n\x06\x04\
    \x05\x04\x05\x02\x03\x12\x04\x8a\x03\x04\x13\x1a\x0c\x20Indicative\n\n\
    \x0f\n\x07\x04\x05\x04\x05\x02\x03\x01\x12\x04\x8a\x03\x04\x0e\n\x0f\n\
    \x07\x04\x05\x04\x05\x02\x03\x02\x12\x04\x8a\x03\x11\x12\n\x1f\n\x06\x04\
    \x05\x04\x05\x02\x04\x12\x04\x8d\x03\x04\x16\x1a\x0f\x20Interrogative\n\
    \n\x0f\n\x07\x04\x05\x04\x05\x02\x04\x01\x12\x04\x8d\x03\x04\x11\n\x0f\n\
    \x07\x04\x05\x04\x05\x02\x04\x02\x12\x04\x8d\x03\x14\x15\n\x19\n\x06\x04\
    \x05\x04\x05\x02\x05\x12\x04\x90\x03\x04\x10\x1a\t\x20Jussive\n\n\x0f\n\
    \x07\x04\x05\x04\x05\x02\x05\x01\x12\x04\x90\x03\x04\x0b\n\x0f\n\x07\x04\
    \x05\x04\x05\x02\x05\x02\x12\x04\x90\x03\x0e\x0f\n\x1d\n\x06\x04\x05\x04\
    \x05\x02\x06\x12\x04\x93\x03\x04\x14\x1a\r\x20Subjunctive\n\n\x0f\n\x07\
    \x04\x05\x04\x05\x02\x06\x01\x12\x04\x93\x03\x04\x0f\n\x0f\n\x07\x04\x05\
    \x04\x05\x02\x06\x02\x12\x04\x93\x03\x12\x13\n%\n\x04\x04\x05\x04\x06\
    \x12\x06\x97\x03\x02\xa3\x03\x03\x1a\x15\x20Count\x20distinctions.\n\n\r\
    \n\x05\x04\x05\x04\x06\x01\x12\x04\x97\x03\x07\r\nX\n\x06\x04\x05\x04\
    \x06\x02\0\x12\x04\x99\x03\x04\x17\x1aH\x20Number\x20is\x20not\x20applic\
    able\x20in\x20the\x20analyzed\x20language\x20or\x20is\x20not\x20predicte\
    d.\n\n\x0f\n\x07\x04\x05\x04\x06\x02\0\x01\x12\x04\x99\x03\x04\x12\n\x0f\
    \n\x07\x04\x05\x04\x06\x02\0\x02\x12\x04\x99\x03\x15\x16\n\x1a\n\x06\x04\
    \x05\x04\x06\x02\x01\x12\x04\x9c\x03\x04\x11\x1a\n\x20Singular\n\n\x0f\n\
    \x07\x04\x05\x04\x06\x02\x01\x01\x12\x04\x9c\x03\x04\x0c\n\x0f\n\x07\x04\
    \x05\x04\x06\x02\x01\x02\x12\x04\x9c\x03\x0f\x10\n\x18\n\x06\x04\x05\x04\
    \x06\x02\x02\x12\x04\x9f\x03\x04\x0f\x1a\x08\x20Plural\n\n\x0f\n\x07\x04\
    \x05\x04\x06\x02\x02\x01\x12\x04\x9f\x03\x04\n\n\x0f\n\x07\x04\x05\x04\
    \x06\x02\x02\x02\x12\x04\x9f\x03\r\x0e\n\x16\n\x06\x04\x05\x04\x06\x02\
    \x03\x12\x04\xa2\x03\x04\r\x1a\x06\x20Dual\n\n\x0f\n\x07\x04\x05\x04\x06\
    \x02\x03\x01\x12\x04\xa2\x03\x04\x08\n\x0f\n\x07\x04\x05\x04\x06\x02\x03\
    \x02\x12\x04\xa2\x03\x0b\x0c\nX\n\x04\x04\x05\x04\x07\x12\x06\xa6\x03\
    \x02\xb5\x03\x03\x1aH\x20The\x20distinction\x20between\x20the\x20speaker\
    ,\x20second\x20person,\x20third\x20person,\x20etc.\n\n\r\n\x05\x04\x05\
    \x04\x07\x01\x12\x04\xa6\x03\x07\r\nX\n\x06\x04\x05\x04\x07\x02\0\x12\
    \x04\xa8\x03\x04\x17\x1aH\x20Person\x20is\x20not\x20applicable\x20in\x20\
    the\x20analyzed\x20language\x20or\x20is\x20not\x20predicted.\n\n\x0f\n\
    \x07\x04\x05\x04\x07\x02\0\x01\x12\x04\xa8\x03\x04\x12\n\x0f\n\x07\x04\
    \x05\x04\x07\x02\0\x02\x12\x04\xa8\x03\x15\x16\n\x17\n\x06\x04\x05\x04\
    \x07\x02\x01\x12\x04\xab\x03\x04\x0e\x1a\x07\x20First\n\n\x0f\n\x07\x04\
    \x05\x04\x07\x02\x01\x01\x12\x04\xab\x03\x04\t\n\x0f\n\x07\x04\x05\x04\
    \x07\x02\x01\x02\x12\x04\xab\x03\x0c\r\n\x18\n\x06\x04\x05\x04\x07\x02\
    \x02\x12\x04\xae\x03\x04\x0f\x1a\x08\x20Second\n\n\x0f\n\x07\x04\x05\x04\
    \x07\x02\x02\x01\x12\x04\xae\x03\x04\n\n\x0f\n\x07\x04\x05\x04\x07\x02\
    \x02\x02\x12\x04\xae\x03\r\x0e\n\x17\n\x06\x04\x05\x04\x07\x02\x03\x12\
    \x04\xb1\x03\x04\x0e\x1a\x07\x20Third\n\n\x0f\n\x07\x04\x05\x04\x07\x02\
    \x03\x01\x12\x04\xb1\x03\x04\t\n\x0f\n\x07\x04\x05\x04\x07\x02\x03\x02\
    \x12\x04\xb1\x03\x0c\r\n\x1b\n\x06\x04\x05\x04\x07\x02\x04\x12\x04\xb4\
    \x03\x04\x19\x1a\x0b\x20Reflexive\n\n\x0f\n\x07\x04\x05\x04\x07\x02\x04\
    \x01\x12\x04\xb4\x03\x04\x14\n\x0f\n\x07\x04\x05\x04\x07\x02\x04\x02\x12\
    \x04\xb4\x03\x17\x18\nL\n\x04\x04\x05\x04\x08\x12\x06\xb8\x03\x02\xc1\
    \x03\x03\x1a<\x20This\x20category\x20shows\x20if\x20the\x20token\x20is\
    \x20part\x20of\x20a\x20proper\x20name.\n\n\r\n\x05\x04\x05\x04\x08\x01\
    \x12\x04\xb8\x03\x07\r\nX\n\x06\x04\x05\x04\x08\x02\0\x12\x04\xba\x03\
    \x04\x17\x1aH\x20Proper\x20is\x20not\x20applicable\x20in\x20the\x20analy\
    zed\x20language\x20or\x20is\x20not\x20predicted.\n\n\x0f\n\x07\x04\x05\
    \x04\x08\x02\0\x01\x12\x04\xba\x03\x04\x12\n\x0f\n\x07\x04\x05\x04\x08\
    \x02\0\x02\x12\x04\xba\x03\x15\x16\n\x18\n\x06\x04\x05\x04\x08\x02\x01\
    \x12\x04\xbd\x03\x04\x0f\x1a\x08\x20Proper\n\n\x0f\n\x07\x04\x05\x04\x08\
    \x02\x01\x01\x12\x04\xbd\x03\x04\n\n\x0f\n\x07\x04\x05\x04\x08\x02\x01\
    \x02\x12\x04\xbd\x03\r\x0e\n\x1c\n\x06\x04\x05\x04\x08\x02\x02\x12\x04\
    \xc0\x03\x04\x13\x1a\x0c\x20Not\x20proper\n\n\x0f\n\x07\x04\x05\x04\x08\
    \x02\x02\x01\x12\x04\xc0\x03\x04\x0e\n\x0f\n\x07\x04\x05\x04\x08\x02\x02\
    \x02\x12\x04\xc0\x03\x11\x12\n3\n\x04\x04\x05\x04\t\x12\x06\xc4\x03\x02\
    \xce\x03\x03\x1a#\x20Reciprocal\x20features\x20of\x20a\x20pronoun.\n\n\r\
    \n\x05\x04\x05\x04\t\x01\x12\x04\xc4\x03\x07\x12\n^\n\x06\x04\x05\x04\t\
    \x02\0\x12\x04\xc7\x03\x04\x1c\x1aN\x20Reciprocity\x20is\x20not\x20appli\
    cable\x20in\x20the\x20analyzed\x20language\x20or\x20is\x20not\n\x20predi\
    cted.\n\n\x0f\n\x07\x04\x05\x04\t\x02\0\x01\x12\x04\xc7\x03\x04\x17\n\
    \x0f\n\x07\x04\x05\x04\t\x02\0\x02\x12\x04\xc7\x03\x1a\x1b\n\x1c\n\x06\
    \x04\x05\x04\t\x02\x01\x12\x04\xca\x03\x04\x13\x1a\x0c\x20Reciprocal\n\n\
    \x0f\n\x07\x04\x05\x04\t\x02\x01\x01\x12\x04\xca\x03\x04\x0e\n\x0f\n\x07\
    \x04\x05\x04\t\x02\x01\x02\x12\x04\xca\x03\x11\x12\n\x20\n\x06\x04\x05\
    \x04\t\x02\x02\x12\x04\xcd\x03\x04\x17\x1a\x10\x20Non-reciprocal\n\n\x0f\
    \n\x07\x04\x05\x04\t\x02\x02\x01\x12\x04\xcd\x03\x04\x12\n\x0f\n\x07\x04\
    \x05\x04\t\x02\x02\x02\x12\x04\xcd\x03\x15\x16\n!\n\x04\x04\x05\x04\n\
    \x12\x06\xd1\x03\x02\xe6\x03\x03\x1a\x11\x20Time\x20reference.\n\n\r\n\
    \x05\x04\x05\x04\n\x01\x12\x04\xd1\x03\x07\x0c\nW\n\x06\x04\x05\x04\n\
    \x02\0\x12\x04\xd3\x03\x04\x16\x1aG\x20Tense\x20is\x20not\x20applicable\
    \x20in\x20the\x20analyzed\x20language\x20or\x20is\x20not\x20predicted.\n\
    \n\x0f\n\x07\x04\x05\x04\n\x02\0\x01\x12\x04\xd3\x03\x04\x11\n\x0f\n\x07\
    \x04\x05\x04\n\x02\0\x02\x12\x04\xd3\x03\x14\x15\n\x1d\n\x06\x04\x05\x04\
    \n\x02\x01\x12\x04\xd6\x03\x04\x1a\x1a\r\x20Conditional\n\n\x0f\n\x07\
    \x04\x05\x04\n\x02\x01\x01\x12\x04\xd6\x03\x04\x15\n\x0f\n\x07\x04\x05\
    \x04\n\x02\x01\x02\x12\x04\xd6\x03\x18\x19\n\x18\n\x06\x04\x05\x04\n\x02\
    \x02\x12\x04\xd9\x03\x04\x0f\x1a\x08\x20Future\n\n\x0f\n\x07\x04\x05\x04\
    \n\x02\x02\x01\x12\x04\xd9\x03\x04\n\n\x0f\n\x07\x04\x05\x04\n\x02\x02\
    \x02\x12\x04\xd9\x03\r\x0e\n\x16\n\x06\x04\x05\x04\n\x02\x03\x12\x04\xdc\
    \x03\x04\r\x1a\x06\x20Past\n\n\x0f\n\x07\x04\x05\x04\n\x02\x03\x01\x12\
    \x04\xdc\x03\x04\x08\n\x0f\n\x07\x04\x05\x04\n\x02\x03\x02\x12\x04\xdc\
    \x03\x0b\x0c\n\x19\n\x06\x04\x05\x04\n\x02\x04\x12\x04\xdf\x03\x04\x10\
    \x1a\t\x20Present\n\n\x0f\n\x07\x04\x05\x04\n\x02\x04\x01\x12\x04\xdf\
    \x03\x04\x0b\n\x0f\n\x07\x04\x05\x04\n\x02\x04\x02\x12\x04\xdf\x03\x0e\
    \x0f\n\x1b\n\x06\x04\x05\x04\n\x02\x05\x12\x04\xe2\x03\x04\x12\x1a\x0b\
    \x20Imperfect\n\n\x0f\n\x07\x04\x05\x04\n\x02\x05\x01\x12\x04\xe2\x03\
    \x04\r\n\x0f\n\x07\x04\x05\x04\n\x02\x05\x02\x12\x04\xe2\x03\x10\x11\n\
    \x1c\n\x06\x04\x05\x04\n\x02\x06\x12\x04\xe5\x03\x04\x13\x1a\x0c\x20Plup\
    erfect\n\n\x0f\n\x07\x04\x05\x04\n\x02\x06\x01\x12\x04\xe5\x03\x04\x0e\n\
    \x0f\n\x07\x04\x05\x04\n\x02\x06\x02\x12\x04\xe5\x03\x11\x12\n~\n\x04\
    \x04\x05\x04\x0b\x12\x06\xea\x03\x02\xf6\x03\x03\x1an\x20The\x20relation\
    ship\x20between\x20the\x20action\x20that\x20a\x20verb\x20expresses\x20an\
    d\x20the\n\x20participants\x20identified\x20by\x20its\x20arguments.\n\n\
    \r\n\x05\x04\x05\x04\x0b\x01\x12\x04\xea\x03\x07\x0c\nW\n\x06\x04\x05\
    \x04\x0b\x02\0\x12\x04\xec\x03\x04\x16\x1aG\x20Voice\x20is\x20not\x20app\
    licable\x20in\x20the\x20analyzed\x20language\x20or\x20is\x20not\x20predi\
    cted.\n\n\x0f\n\x07\x04\x05\x04\x0b\x02\0\x01\x12\x04\xec\x03\x04\x11\n\
    \x0f\n\x07\x04\x05\x04\x0b\x02\0\x02\x12\x04\xec\x03\x14\x15\n\x18\n\x06\
    \x04\x05\x04\x0b\x02\x01\x12\x04\xef\x03\x04\x0f\x1a\x08\x20Active\n\n\
    \x0f\n\x07\x04\x05\x04\x0b\x02\x01\x01\x12\x04\xef\x03\x04\n\n\x0f\n\x07\
    \x04\x05\x04\x0b\x02\x01\x02\x12\x04\xef\x03\r\x0e\n\x1b\n\x06\x04\x05\
    \x04\x0b\x02\x02\x12\x04\xf2\x03\x04\x12\x1a\x0b\x20Causative\n\n\x0f\n\
    \x07\x04\x05\x04\x0b\x02\x02\x01\x12\x04\xf2\x03\x04\r\n\x0f\n\x07\x04\
    \x05\x04\x0b\x02\x02\x02\x12\x04\xf2\x03\x10\x11\n\x19\n\x06\x04\x05\x04\
    \x0b\x02\x03\x12\x04\xf5\x03\x04\x10\x1a\t\x20Passive\n\n\x0f\n\x07\x04\
    \x05\x04\x0b\x02\x03\x01\x12\x04\xf5\x03\x04\x0b\n\x0f\n\x07\x04\x05\x04\
    \x0b\x02\x03\x02\x12\x04\xf5\x03\x0e\x0f\n'\n\x04\x04\x05\x02\0\x12\x04\
    \xf9\x03\x02\x0e\x1a\x19\x20The\x20part\x20of\x20speech\x20tag.\n\n\x0f\
    \n\x05\x04\x05\x02\0\x04\x12\x06\xf9\x03\x02\xf6\x03\x03\n\r\n\x05\x04\
    \x05\x02\0\x06\x12\x04\xf9\x03\x02\x05\n\r\n\x05\x04\x05\x02\0\x01\x12\
    \x04\xf9\x03\x06\t\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xf9\x03\x0c\r\n'\
    \n\x04\x04\x05\x02\x01\x12\x04\xfc\x03\x02\x14\x1a\x19\x20The\x20grammat\
    ical\x20aspect.\n\n\x0f\n\x05\x04\x05\x02\x01\x04\x12\x06\xfc\x03\x02\
    \xf9\x03\x0e\n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\xfc\x03\x02\x08\n\r\n\
    \x05\x04\x05\x02\x01\x01\x12\x04\xfc\x03\t\x0f\n\r\n\x05\x04\x05\x02\x01\
    \x03\x12\x04\xfc\x03\x12\x13\n%\n\x04\x04\x05\x02\x02\x12\x04\xff\x03\
    \x02\x10\x1a\x17\x20The\x20grammatical\x20case.\n\n\x0f\n\x05\x04\x05\
    \x02\x02\x04\x12\x06\xff\x03\x02\xfc\x03\x14\n\r\n\x05\x04\x05\x02\x02\
    \x06\x12\x04\xff\x03\x02\x06\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xff\
    \x03\x07\x0b\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xff\x03\x0e\x0f\n%\n\
    \x04\x04\x05\x02\x03\x12\x04\x82\x04\x02\x10\x1a\x17\x20The\x20grammatic\
    al\x20form.\n\n\x0f\n\x05\x04\x05\x02\x03\x04\x12\x06\x82\x04\x02\xff\
    \x03\x10\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\x82\x04\x02\x06\n\r\n\x05\
    \x04\x05\x02\x03\x01\x12\x04\x82\x04\x07\x0b\n\r\n\x05\x04\x05\x02\x03\
    \x03\x12\x04\x82\x04\x0e\x0f\n'\n\x04\x04\x05\x02\x04\x12\x04\x85\x04\
    \x02\x14\x1a\x19\x20The\x20grammatical\x20gender.\n\n\x0f\n\x05\x04\x05\
    \x02\x04\x04\x12\x06\x85\x04\x02\x82\x04\x10\n\r\n\x05\x04\x05\x02\x04\
    \x06\x12\x04\x85\x04\x02\x08\n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\x85\
    \x04\t\x0f\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\x85\x04\x12\x13\n%\n\
    \x04\x04\x05\x02\x05\x12\x04\x88\x04\x02\x10\x1a\x17\x20The\x20grammatic\
    al\x20mood.\n\n\x0f\n\x05\x04\x05\x02\x05\x04\x12\x06\x88\x04\x02\x85\
    \x04\x14\n\r\n\x05\x04\x05\x02\x05\x06\x12\x04\x88\x04\x02\x06\n\r\n\x05\
    \x04\x05\x02\x05\x01\x12\x04\x88\x04\x07\x0b\n\r\n\x05\x04\x05\x02\x05\
    \x03\x12\x04\x88\x04\x0e\x0f\n'\n\x04\x04\x05\x02\x06\x12\x04\x8b\x04\
    \x02\x14\x1a\x19\x20The\x20grammatical\x20number.\n\n\x0f\n\x05\x04\x05\
    \x02\x06\x04\x12\x06\x8b\x04\x02\x88\x04\x10\n\r\n\x05\x04\x05\x02\x06\
    \x06\x12\x04\x8b\x04\x02\x08\n\r\n\x05\x04\x05\x02\x06\x01\x12\x04\x8b\
    \x04\t\x0f\n\r\n\x05\x04\x05\x02\x06\x03\x12\x04\x8b\x04\x12\x13\n'\n\
    \x04\x04\x05\x02\x07\x12\x04\x8e\x04\x02\x14\x1a\x19\x20The\x20grammatic\
    al\x20person.\n\n\x0f\n\x05\x04\x05\x02\x07\x04\x12\x06\x8e\x04\x02\x8b\
    \x04\x14\n\r\n\x05\x04\x05\x02\x07\x06\x12\x04\x8e\x04\x02\x08\n\r\n\x05\
    \x04\x05\x02\x07\x01\x12\x04\x8e\x04\t\x0f\n\r\n\x05\x04\x05\x02\x07\x03\
    \x12\x04\x8e\x04\x12\x13\n+\n\x04\x04\x05\x02\x08\x12\x04\x91\x04\x02\
    \x14\x1a\x1d\x20The\x20grammatical\x20properness.\n\n\x0f\n\x05\x04\x05\
    \x02\x08\x04\x12\x06\x91\x04\x02\x8e\x04\x14\n\r\n\x05\x04\x05\x02\x08\
    \x06\x12\x04\x91\x04\x02\x08\n\r\n\x05\x04\x05\x02\x08\x01\x12\x04\x91\
    \x04\t\x0f\n\r\n\x05\x04\x05\x02\x08\x03\x12\x04\x91\x04\x12\x13\n,\n\
    \x04\x04\x05\x02\t\x12\x04\x94\x04\x02\x1f\x1a\x1e\x20The\x20grammatical\
    \x20reciprocity.\n\n\x0f\n\x05\x04\x05\x02\t\x04\x12\x06\x94\x04\x02\x91\
    \x04\x14\n\r\n\x05\x04\x05\x02\t\x06\x12\x04\x94\x04\x02\r\n\r\n\x05\x04\
    \x05\x02\t\x01\x12\x04\x94\x04\x0e\x19\n\r\n\x05\x04\x05\x02\t\x03\x12\
    \x04\x94\x04\x1c\x1e\n&\n\x04\x04\x05\x02\n\x12\x04\x97\x04\x02\x13\x1a\
    \x18\x20The\x20grammatical\x20tense.\n\n\x0f\n\x05\x04\x05\x02\n\x04\x12\
    \x06\x97\x04\x02\x94\x04\x1f\n\r\n\x05\x04\x05\x02\n\x06\x12\x04\x97\x04\
    \x02\x07\n\r\n\x05\x04\x05\x02\n\x01\x12\x04\x97\x04\x08\r\n\r\n\x05\x04\
    \x05\x02\n\x03\x12\x04\x97\x04\x10\x12\n&\n\x04\x04\x05\x02\x0b\x12\x04\
    \x9a\x04\x02\x13\x1a\x18\x20The\x20grammatical\x20voice.\n\n\x0f\n\x05\
    \x04\x05\x02\x0b\x04\x12\x06\x9a\x04\x02\x97\x04\x13\n\r\n\x05\x04\x05\
    \x02\x0b\x06\x12\x04\x9a\x04\x02\x07\n\r\n\x05\x04\x05\x02\x0b\x01\x12\
    \x04\x9a\x04\x08\r\n\r\n\x05\x04\x05\x02\x0b\x03\x12\x04\x9a\x04\x10\x12\
    \n\xa5\x01\n\x02\x04\x06\x12\x06\xa0\x04\0\xa6\x06\x01\x1a\x96\x01\x20Re\
    presents\x20dependency\x20parse\x20tree\x20information\x20for\x20a\x20to\
    ken.\x20(For\x20more\n\x20information\x20on\x20dependency\x20labels,\x20\
    see\n\x20http://www.aclweb.org/anthology/P13-2017\n\n\x0b\n\x03\x04\x06\
    \x01\x12\x04\xa0\x04\x08\x16\n5\n\x04\x04\x06\x04\0\x12\x06\xa2\x04\x02\
    \x9b\x06\x03\x1a%\x20The\x20parse\x20label\x20enum\x20for\x20the\x20toke\
    n.\n\n\r\n\x05\x04\x06\x04\0\x01\x12\x04\xa2\x04\x07\x0c\n\x19\n\x06\x04\
    \x06\x04\0\x02\0\x12\x04\xa4\x04\x04\x10\x1a\t\x20Unknown\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02\0\x01\x12\x04\xa4\x04\x04\x0b\n\x0f\n\x07\x04\x06\x04\
    \0\x02\0\x02\x12\x04\xa4\x04\x0e\x0f\n'\n\x06\x04\x06\x04\0\x02\x01\x12\
    \x04\xa7\x04\x04\x0f\x1a\x17\x20Abbreviation\x20modifier\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x01\x01\x12\x04\xa7\x04\x04\n\n\x0f\n\x07\x04\x06\x04\
    \0\x02\x01\x02\x12\x04\xa7\x04\r\x0e\n'\n\x06\x04\x06\x04\0\x02\x02\x12\
    \x04\xaa\x04\x04\x0e\x1a\x17\x20Adjectival\x20complement\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x02\x01\x12\x04\xaa\x04\x04\t\n\x0f\n\x07\x04\x06\x04\
    \0\x02\x02\x02\x12\x04\xaa\x04\x0c\r\n+\n\x06\x04\x06\x04\0\x02\x03\x12\
    \x04\xad\x04\x04\x0e\x1a\x1b\x20Adverbial\x20clause\x20modifier\n\n\x0f\
    \n\x07\x04\x06\x04\0\x02\x03\x01\x12\x04\xad\x04\x04\t\n\x0f\n\x07\x04\
    \x06\x04\0\x02\x03\x02\x12\x04\xad\x04\x0c\r\n$\n\x06\x04\x06\x04\0\x02\
    \x04\x12\x04\xb0\x04\x04\x0f\x1a\x14\x20Adverbial\x20modifier\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x04\x01\x12\x04\xb0\x04\x04\n\n\x0f\n\x07\x04\x06\
    \x04\0\x02\x04\x02\x12\x04\xb0\x04\r\x0e\n.\n\x06\x04\x06\x04\0\x02\x05\
    \x12\x04\xb3\x04\x04\r\x1a\x1e\x20Adjectival\x20modifier\x20of\x20an\x20\
    NP\n\n\x0f\n\x07\x04\x06\x04\0\x02\x05\x01\x12\x04\xb3\x04\x04\x08\n\x0f\
    \n\x07\x04\x06\x04\0\x02\x05\x02\x12\x04\xb3\x04\x0b\x0c\n0\n\x06\x04\
    \x06\x04\0\x02\x06\x12\x04\xb6\x04\x04\x0e\x1a\x20\x20Appositional\x20mo\
    difier\x20of\x20an\x20NP\n\n\x0f\n\x07\x04\x06\x04\0\x02\x06\x01\x12\x04\
    \xb6\x04\x04\t\n\x0f\n\x07\x04\x06\x04\0\x02\x06\x02\x12\x04\xb6\x04\x0c\
    \r\n7\n\x06\x04\x06\x04\0\x02\x07\x12\x04\xb9\x04\x04\r\x1a'\x20Attribut\
    e\x20dependent\x20of\x20a\x20copular\x20verb\n\n\x0f\n\x07\x04\x06\x04\0\
    \x02\x07\x01\x12\x04\xb9\x04\x04\x08\n\x0f\n\x07\x04\x06\x04\0\x02\x07\
    \x02\x12\x04\xb9\x04\x0b\x0c\n+\n\x06\x04\x06\x04\0\x02\x08\x12\x04\xbc\
    \x04\x04\x0c\x1a\x1b\x20Auxiliary\x20(non-main)\x20verb\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x08\x01\x12\x04\xbc\x04\x04\x07\n\x0f\n\x07\x04\x06\
    \x04\0\x02\x08\x02\x12\x04\xbc\x04\n\x0b\n#\n\x06\x04\x06\x04\0\x02\t\
    \x12\x04\xbf\x04\x04\x10\x1a\x13\x20Passive\x20auxiliary\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02\t\x01\x12\x04\xbf\x04\x04\x0b\n\x0f\n\x07\x04\x06\x04\
    \0\x02\t\x02\x12\x04\xbf\x04\x0e\x0f\n*\n\x06\x04\x06\x04\0\x02\n\x12\
    \x04\xc2\x04\x04\x0c\x1a\x1a\x20Coordinating\x20conjunction\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02\n\x01\x12\x04\xc2\x04\x04\x06\n\x0f\n\x07\x04\x06\
    \x04\0\x02\n\x02\x12\x04\xc2\x04\t\x0b\n;\n\x06\x04\x06\x04\0\x02\x0b\
    \x12\x04\xc5\x04\x04\x0f\x1a+\x20Clausal\x20complement\x20of\x20a\x20ver\
    b\x20or\x20adjective\n\n\x0f\n\x07\x04\x06\x04\0\x02\x0b\x01\x12\x04\xc5\
    \x04\x04\t\n\x0f\n\x07\x04\x06\x04\0\x02\x0b\x02\x12\x04\xc5\x04\x0c\x0e\
    \n\x1a\n\x06\x04\x06\x04\0\x02\x0c\x12\x04\xc8\x04\x04\x0e\x1a\n\x20Conj\
    unct\n\n\x0f\n\x07\x04\x06\x04\0\x02\x0c\x01\x12\x04\xc8\x04\x04\x08\n\
    \x0f\n\x07\x04\x06\x04\0\x02\x0c\x02\x12\x04\xc8\x04\x0b\r\n!\n\x06\x04\
    \x06\x04\0\x02\r\x12\x04\xcb\x04\x04\x0f\x1a\x11\x20Clausal\x20subject\n\
    \n\x0f\n\x07\x04\x06\x04\0\x02\r\x01\x12\x04\xcb\x04\x04\t\n\x0f\n\x07\
    \x04\x06\x04\0\x02\r\x02\x12\x04\xcb\x04\x0c\x0e\n)\n\x06\x04\x06\x04\0\
    \x02\x0e\x12\x04\xce\x04\x04\x13\x1a\x19\x20Clausal\x20passive\x20subjec\
    t\n\n\x0f\n\x07\x04\x06\x04\0\x02\x0e\x01\x12\x04\xce\x04\x04\r\n\x0f\n\
    \x07\x04\x06\x04\0\x02\x0e\x02\x12\x04\xce\x04\x10\x12\n2\n\x06\x04\x06\
    \x04\0\x02\x0f\x12\x04\xd1\x04\x04\r\x1a\"\x20Dependency\x20(unable\x20t\
    o\x20determine)\n\n\x0f\n\x07\x04\x06\x04\0\x02\x0f\x01\x12\x04\xd1\x04\
    \x04\x07\n\x0f\n\x07\x04\x06\x04\0\x02\x0f\x02\x12\x04\xd1\x04\n\x0c\n\
    \x1c\n\x06\x04\x06\x04\0\x02\x10\x12\x04\xd4\x04\x04\r\x1a\x0c\x20Determ\
    iner\n\n\x0f\n\x07\x04\x06\x04\0\x02\x10\x01\x12\x04\xd4\x04\x04\x07\n\
    \x0f\n\x07\x04\x06\x04\0\x02\x10\x02\x12\x04\xd4\x04\n\x0c\n\x1b\n\x06\
    \x04\x06\x04\0\x02\x11\x12\x04\xd7\x04\x04\x13\x1a\x0b\x20Discourse\n\n\
    \x0f\n\x07\x04\x06\x04\0\x02\x11\x01\x12\x04\xd7\x04\x04\r\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x11\x02\x12\x04\xd7\x04\x10\x12\n\x1f\n\x06\x04\x06\
    \x04\0\x02\x12\x12\x04\xda\x04\x04\x0e\x1a\x0f\x20Direct\x20object\n\n\
    \x0f\n\x07\x04\x06\x04\0\x02\x12\x01\x12\x04\xda\x04\x04\x08\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x12\x02\x12\x04\xda\x04\x0b\r\n\x1b\n\x06\x04\x06\x04\
    \0\x02\x13\x12\x04\xdd\x04\x04\x0e\x1a\x0b\x20Expletive\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x13\x01\x12\x04\xdd\x04\x04\x08\n\x0f\n\x07\x04\x06\
    \x04\0\x02\x13\x02\x12\x04\xdd\x04\x0b\r\nF\n\x06\x04\x06\x04\0\x02\x14\
    \x12\x04\xe0\x04\x04\x12\x1a6\x20Goes\x20with\x20(part\x20of\x20a\x20wor\
    d\x20in\x20a\x20text\x20not\x20well\x20edited)\n\n\x0f\n\x07\x04\x06\x04\
    \0\x02\x14\x01\x12\x04\xe0\x04\x04\x0c\n\x0f\n\x07\x04\x06\x04\0\x02\x14\
    \x02\x12\x04\xe0\x04\x0f\x11\n!\n\x06\x04\x06\x04\0\x02\x15\x12\x04\xe3\
    \x04\x04\x0e\x1a\x11\x20Indirect\x20object\n\n\x0f\n\x07\x04\x06\x04\0\
    \x02\x15\x01\x12\x04\xe3\x04\x04\x08\n\x0f\n\x07\x04\x06\x04\0\x02\x15\
    \x02\x12\x04\xe3\x04\x0b\r\n@\n\x06\x04\x06\x04\0\x02\x16\x12\x04\xe6\
    \x04\x04\x0e\x1a0\x20Marker\x20(word\x20introducing\x20a\x20subordinate\
    \x20clause)\n\n\x0f\n\x07\x04\x06\x04\0\x02\x16\x01\x12\x04\xe6\x04\x04\
    \x08\n\x0f\n\x07\x04\x06\x04\0\x02\x16\x02\x12\x04\xe6\x04\x0b\r\n'\n\
    \x06\x04\x06\x04\0\x02\x17\x12\x04\xe9\x04\x04\r\x1a\x17\x20Multi-word\
    \x20expression\n\n\x0f\n\x07\x04\x06\x04\0\x02\x17\x01\x12\x04\xe9\x04\
    \x04\x07\n\x0f\n\x07\x04\x06\x04\0\x02\x17\x02\x12\x04\xe9\x04\n\x0c\n.\
    \n\x06\x04\x06\x04\0\x02\x18\x12\x04\xec\x04\x04\r\x1a\x1e\x20Multi-word\
    \x20verbal\x20expression\n\n\x0f\n\x07\x04\x06\x04\0\x02\x18\x01\x12\x04\
    \xec\x04\x04\x07\n\x0f\n\x07\x04\x06\x04\0\x02\x18\x02\x12\x04\xec\x04\n\
    \x0c\n#\n\x06\x04\x06\x04\0\x02\x19\x12\x04\xef\x04\x04\r\x1a\x13\x20Neg\
    ation\x20modifier\n\n\x0f\n\x07\x04\x06\x04\0\x02\x19\x01\x12\x04\xef\
    \x04\x04\x07\n\x0f\n\x07\x04\x06\x04\0\x02\x19\x02\x12\x04\xef\x04\n\x0c\
    \n(\n\x06\x04\x06\x04\0\x02\x1a\x12\x04\xf2\x04\x04\x0c\x1a\x18\x20Noun\
    \x20compound\x20modifier\n\n\x0f\n\x07\x04\x06\x04\0\x02\x1a\x01\x12\x04\
    \xf2\x04\x04\x06\n\x0f\n\x07\x04\x06\x04\0\x02\x1a\x02\x12\x04\xf2\x04\t\
    \x0b\n;\n\x06\x04\x06\x04\0\x02\x1b\x12\x04\xf5\x04\x04\x12\x1a+\x20Noun\
    \x20phrase\x20used\x20as\x20an\x20adverbial\x20modifier\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x1b\x01\x12\x04\xf5\x04\x04\x0c\n\x0f\n\x07\x04\x06\
    \x04\0\x02\x1b\x02\x12\x04\xf5\x04\x0f\x11\n!\n\x06\x04\x06\x04\0\x02\
    \x1c\x12\x04\xf8\x04\x04\x0f\x1a\x11\x20Nominal\x20subject\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x1c\x01\x12\x04\xf8\x04\x04\t\n\x0f\n\x07\x04\x06\x04\
    \0\x02\x1c\x02\x12\x04\xf8\x04\x0c\x0e\n)\n\x06\x04\x06\x04\0\x02\x1d\
    \x12\x04\xfb\x04\x04\x13\x1a\x19\x20Passive\x20nominal\x20subject\n\n\
    \x0f\n\x07\x04\x06\x04\0\x02\x1d\x01\x12\x04\xfb\x04\x04\r\n\x0f\n\x07\
    \x04\x06\x04\0\x02\x1d\x02\x12\x04\xfb\x04\x10\x12\n,\n\x06\x04\x06\x04\
    \0\x02\x1e\x12\x04\xfe\x04\x04\r\x1a\x1c\x20Numeric\x20modifier\x20of\
    \x20a\x20noun\n\n\x0f\n\x07\x04\x06\x04\0\x02\x1e\x01\x12\x04\xfe\x04\
    \x04\x07\n\x0f\n\x07\x04\x06\x04\0\x02\x1e\x02\x12\x04\xfe\x04\n\x0c\n,\
    \n\x06\x04\x06\x04\0\x02\x1f\x12\x04\x81\x05\x04\x10\x1a\x1c\x20Element\
    \x20of\x20compound\x20number\n\n\x0f\n\x07\x04\x06\x04\0\x02\x1f\x01\x12\
    \x04\x81\x05\x04\n\n\x0f\n\x07\x04\x06\x04\0\x02\x1f\x02\x12\x04\x81\x05\
    \r\x0f\n\"\n\x06\x04\x06\x04\0\x02\x20\x12\x04\x84\x05\x04\x0b\x1a\x12\
    \x20Punctuation\x20mark\n\n\x0f\n\x07\x04\x06\x04\0\x02\x20\x01\x12\x04\
    \x84\x05\x04\x05\n\x0f\n\x07\x04\x06\x04\0\x02\x20\x02\x12\x04\x84\x05\
    \x08\n\n$\n\x06\x04\x06\x04\0\x02!\x12\x04\x87\x05\x04\x13\x1a\x14\x20Pa\
    rataxis\x20relation\n\n\x0f\n\x07\x04\x06\x04\0\x02!\x01\x12\x04\x87\x05\
    \x04\r\n\x0f\n\x07\x04\x06\x04\0\x02!\x02\x12\x04\x87\x05\x10\x12\n&\n\
    \x06\x04\x06\x04\0\x02\"\x12\x04\x8a\x05\x04\x11\x1a\x16\x20Participial\
    \x20modifier\n\n\x0f\n\x07\x04\x06\x04\0\x02\"\x01\x12\x04\x8a\x05\x04\
    \x0b\n\x0f\n\x07\x04\x06\x04\0\x02\"\x02\x12\x04\x8a\x05\x0e\x10\n=\n\
    \x06\x04\x06\x04\0\x02#\x12\x04\x8d\x05\x04\x0f\x1a-\x20The\x20complemen\
    t\x20of\x20a\x20preposition\x20is\x20a\x20clause\n\n\x0f\n\x07\x04\x06\
    \x04\0\x02#\x01\x12\x04\x8d\x05\x04\t\n\x0f\n\x07\x04\x06\x04\0\x02#\x02\
    \x12\x04\x8d\x05\x0c\x0e\n)\n\x06\x04\x06\x04\0\x02$\x12\x04\x90\x05\x04\
    \x0e\x1a\x19\x20Object\x20of\x20a\x20preposition\n\n\x0f\n\x07\x04\x06\
    \x04\0\x02$\x01\x12\x04\x90\x05\x04\x08\n\x0f\n\x07\x04\x06\x04\0\x02$\
    \x02\x12\x04\x90\x05\x0b\r\n%\n\x06\x04\x06\x04\0\x02%\x12\x04\x93\x05\
    \x04\x0e\x1a\x15\x20Possession\x20modifier\n\n\x0f\n\x07\x04\x06\x04\0\
    \x02%\x01\x12\x04\x93\x05\x04\x08\n\x0f\n\x07\x04\x06\x04\0\x02%\x02\x12\
    \x04\x93\x05\x0b\r\n.\n\x06\x04\x06\x04\0\x02&\x12\x04\x96\x05\x04\x11\
    \x1a\x1e\x20Postverbal\x20negative\x20particle\n\n\x0f\n\x07\x04\x06\x04\
    \0\x02&\x01\x12\x04\x96\x05\x04\x0b\n\x0f\n\x07\x04\x06\x04\0\x02&\x02\
    \x12\x04\x96\x05\x0e\x10\n&\n\x06\x04\x06\x04\0\x02'\x12\x04\x99\x05\x04\
    \x11\x1a\x16\x20Predicate\x20complement\n\n\x0f\n\x07\x04\x06\x04\0\x02'\
    \x01\x12\x04\x99\x05\x04\x0b\n\x0f\n\x07\x04\x06\x04\0\x02'\x02\x12\x04\
    \x99\x05\x0e\x10\n\x1c\n\x06\x04\x06\x04\0\x02(\x12\x04\x9c\x05\x04\x11\
    \x1a\x0c\x20Preconjunt\n\n\x0f\n\x07\x04\x06\x04\0\x02(\x01\x12\x04\x9c\
    \x05\x04\x0b\n\x0f\n\x07\x04\x06\x04\0\x02(\x02\x12\x04\x9c\x05\x0e\x10\
    \n\x1f\n\x06\x04\x06\x04\0\x02)\x12\x04\x9f\x05\x04\x10\x1a\x0f\x20Prede\
    terminer\n\n\x0f\n\x07\x04\x06\x04\0\x02)\x01\x12\x04\x9f\x05\x04\n\n\
    \x0f\n\x07\x04\x06\x04\0\x02)\x02\x12\x04\x9f\x05\r\x0f\n\x18\n\x06\x04\
    \x06\x04\0\x02*\x12\x04\xa2\x05\x04\x0e\x1a\x08\x20Prefix\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02*\x01\x12\x04\xa2\x05\x04\x08\n\x0f\n\x07\x04\x06\x04\
    \0\x02*\x02\x12\x04\xa2\x05\x0b\r\n(\n\x06\x04\x06\x04\0\x02+\x12\x04\
    \xa5\x05\x04\x0e\x1a\x18\x20Prepositional\x20modifier\n\n\x0f\n\x07\x04\
    \x06\x04\0\x02+\x01\x12\x04\xa5\x05\x04\x08\n\x0f\n\x07\x04\x06\x04\0\
    \x02+\x02\x12\x04\xa5\x05\x0b\r\nE\n\x06\x04\x06\x04\0\x02,\x12\x04\xa8\
    \x05\x04\x0f\x1a5\x20The\x20relationship\x20between\x20a\x20verb\x20and\
    \x20verbal\x20morpheme\n\n\x0f\n\x07\x04\x06\x04\0\x02,\x01\x12\x04\xa8\
    \x05\x04\t\n\x0f\n\x07\x04\x06\x04\0\x02,\x02\x12\x04\xa8\x05\x0c\x0e\n\
    \x1a\n\x06\x04\x06\x04\0\x02-\x12\x04\xab\x05\x04\r\x1a\n\x20Particle\n\
    \n\x0f\n\x07\x04\x06\x04\0\x02-\x01\x12\x04\xab\x05\x04\x07\n\x0f\n\x07\
    \x04\x06\x04\0\x02-\x02\x12\x04\xab\x05\n\x0c\n2\n\x06\x04\x06\x04\0\x02\
    .\x12\x04\xae\x05\x04\x0c\x1a\"\x20Associative\x20or\x20possessive\x20ma\
    rker\n\n\x0f\n\x07\x04\x06\x04\0\x02.\x01\x12\x04\xae\x05\x04\x06\n\x0f\
    \n\x07\x04\x06\x04\0\x02.\x02\x12\x04\xae\x05\t\x0b\n,\n\x06\x04\x06\x04\
    \0\x02/\x12\x04\xb1\x05\x04\x12\x1a\x1c\x20Quantifier\x20phrase\x20modif\
    ier\n\n\x0f\n\x07\x04\x06\x04\0\x02/\x01\x12\x04\xb1\x05\x04\x0c\n\x0f\n\
    \x07\x04\x06\x04\0\x02/\x02\x12\x04\xb1\x05\x0f\x11\n*\n\x06\x04\x06\x04\
    \0\x020\x12\x04\xb4\x05\x04\x0f\x1a\x1a\x20Relative\x20clause\x20modifie\
    r\n\n\x0f\n\x07\x04\x06\x04\0\x020\x01\x12\x04\xb4\x05\x04\t\n\x0f\n\x07\
    \x04\x06\x04\0\x020\x02\x12\x04\xb4\x05\x0c\x0e\n3\n\x06\x04\x06\x04\0\
    \x021\x12\x04\xb7\x05\x04\x12\x1a#\x20Complementizer\x20in\x20relative\
    \x20clause\n\n\x0f\n\x07\x04\x06\x04\0\x021\x01\x12\x04\xb7\x05\x04\x0c\
    \n\x0f\n\x07\x04\x06\x04\0\x021\x02\x12\x04\xb7\x05\x0f\x11\n8\n\x06\x04\
    \x06\x04\0\x022\x12\x04\xba\x05\x04\x0f\x1a(\x20Ellipsis\x20without\x20a\
    \x20preceding\x20predicate\n\n\x0f\n\x07\x04\x06\x04\0\x022\x01\x12\x04\
    \xba\x05\x04\t\n\x0f\n\x07\x04\x06\x04\0\x022\x02\x12\x04\xba\x05\x0c\
    \x0e\n\x1a\n\x06\x04\x06\x04\0\x023\x12\x04\xbd\x05\x04\r\x1a\n\x20Refer\
    ent\n\n\x0f\n\x07\x04\x06\x04\0\x023\x01\x12\x04\xbd\x05\x04\x07\n\x0f\n\
    \x07\x04\x06\x04\0\x023\x02\x12\x04\xbd\x05\n\x0c\n\x19\n\x06\x04\x06\
    \x04\0\x024\x12\x04\xc0\x05\x04\x11\x1a\t\x20Remnant\n\n\x0f\n\x07\x04\
    \x06\x04\0\x024\x01\x12\x04\xc0\x05\x04\x0b\n\x0f\n\x07\x04\x06\x04\0\
    \x024\x02\x12\x04\xc0\x05\x0e\x10\n\x1c\n\x06\x04\x06\x04\0\x025\x12\x04\
    \xc3\x05\x04\x14\x1a\x0c\x20Reparandum\n\n\x0f\n\x07\x04\x06\x04\0\x025\
    \x01\x12\x04\xc3\x05\x04\x0e\n\x0f\n\x07\x04\x06\x04\0\x025\x02\x12\x04\
    \xc3\x05\x11\x13\n\x16\n\x06\x04\x06\x04\0\x026\x12\x04\xc6\x05\x04\x0e\
    \x1a\x06\x20Root\n\n\x0f\n\x07\x04\x06\x04\0\x026\x01\x12\x04\xc6\x05\
    \x04\x08\n\x0f\n\x07\x04\x06\x04\0\x026\x02\x12\x04\xc6\x05\x0b\r\n4\n\
    \x06\x04\x06\x04\0\x027\x12\x04\xc9\x05\x04\x0e\x1a$\x20Suffix\x20specif\
    ying\x20a\x20unit\x20of\x20number\n\n\x0f\n\x07\x04\x06\x04\0\x027\x01\
    \x12\x04\xc9\x05\x04\x08\n\x0f\n\x07\x04\x06\x04\0\x027\x02\x12\x04\xc9\
    \x05\x0b\r\n\x18\n\x06\x04\x06\x04\0\x028\x12\x04\xcc\x05\x04\x0e\x1a\
    \x08\x20Suffix\n\n\x0f\n\x07\x04\x06\x04\0\x028\x01\x12\x04\xcc\x05\x04\
    \x08\n\x0f\n\x07\x04\x06\x04\0\x028\x02\x12\x04\xcc\x05\x0b\r\n#\n\x06\
    \x04\x06\x04\0\x029\x12\x04\xcf\x05\x04\x0e\x1a\x13\x20Temporal\x20modif\
    ier\n\n\x0f\n\x07\x04\x06\x04\0\x029\x01\x12\x04\xcf\x05\x04\x08\n\x0f\n\
    \x07\x04\x06\x04\0\x029\x02\x12\x04\xcf\x05\x0b\r\n\x1e\n\x06\x04\x06\
    \x04\0\x02:\x12\x04\xd2\x05\x04\x0f\x1a\x0e\x20Topic\x20marker\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02:\x01\x12\x04\xd2\x05\x04\t\n\x0f\n\x07\x04\x06\
    \x04\0\x02:\x02\x12\x04\xd2\x05\x0c\x0e\nT\n\x06\x04\x06\x04\0\x02;\x12\
    \x04\xd5\x05\x04\x0e\x1aD\x20Clause\x20headed\x20by\x20an\x20infinite\
    \x20form\x20of\x20the\x20verb\x20that\x20modifies\x20a\x20noun\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02;\x01\x12\x04\xd5\x05\x04\x08\n\x0f\n\x07\x04\x06\
    \x04\0\x02;\x02\x12\x04\xd5\x05\x0b\r\n\x1a\n\x06\x04\x06\x04\0\x02<\x12\
    \x04\xd8\x05\x04\x12\x1a\n\x20Vocative\n\n\x0f\n\x07\x04\x06\x04\0\x02<\
    \x01\x12\x04\xd8\x05\x04\x0c\n\x0f\n\x07\x04\x06\x04\0\x02<\x02\x12\x04\
    \xd8\x05\x0f\x11\n)\n\x06\x04\x06\x04\0\x02=\x12\x04\xdb\x05\x04\x0f\x1a\
    \x19\x20Open\x20clausal\x20complement\n\n\x0f\n\x07\x04\x06\x04\0\x02=\
    \x01\x12\x04\xdb\x05\x04\t\n\x0f\n\x07\x04\x06\x04\0\x02=\x02\x12\x04\
    \xdb\x05\x0c\x0e\n\x1d\n\x06\x04\x06\x04\0\x02>\x12\x04\xde\x05\x04\x10\
    \x1a\r\x20Name\x20suffix\n\n\x0f\n\x07\x04\x06\x04\0\x02>\x01\x12\x04\
    \xde\x05\x04\n\n\x0f\n\x07\x04\x06\x04\0\x02>\x02\x12\x04\xde\x05\r\x0f\
    \n\x1c\n\x06\x04\x06\x04\0\x02?\x12\x04\xe1\x05\x04\x0f\x1a\x0c\x20Name\
    \x20title\n\n\x0f\n\x07\x04\x06\x04\0\x02?\x01\x12\x04\xe1\x05\x04\t\n\
    \x0f\n\x07\x04\x06\x04\0\x02?\x02\x12\x04\xe1\x05\x0c\x0e\n+\n\x06\x04\
    \x06\x04\0\x02@\x12\x04\xe4\x05\x04\x12\x1a\x1b\x20Adverbial\x20phrase\
    \x20modifier\n\n\x0f\n\x07\x04\x06\x04\0\x02@\x01\x12\x04\xe4\x05\x04\
    \x0c\n\x0f\n\x07\x04\x06\x04\0\x02@\x02\x12\x04\xe4\x05\x0f\x11\n%\n\x06\
    \x04\x06\x04\0\x02A\x12\x04\xe7\x05\x04\x11\x1a\x15\x20Causative\x20auxi\
    liary\n\n\x0f\n\x07\x04\x06\x04\0\x02A\x01\x12\x04\xe7\x05\x04\x0b\n\x0f\
    \n\x07\x04\x06\x04\0\x02A\x02\x12\x04\xe7\x05\x0e\x10\n\"\n\x06\x04\x06\
    \x04\0\x02B\x12\x04\xea\x05\x04\x0f\x1a\x12\x20Helper\x20auxiliary\n\n\
    \x0f\n\x07\x04\x06\x04\0\x02B\x01\x12\x04\xea\x05\x04\t\n\x0f\n\x07\x04\
    \x06\x04\0\x02B\x02\x12\x04\xea\x05\x0c\x0e\n1\n\x06\x04\x06\x04\0\x02C\
    \x12\x04\xed\x05\x04\x0f\x1a!\x20Rentaishi\x20(Prenominal\x20modifier)\n\
    \n\x0f\n\x07\x04\x06\x04\0\x02C\x01\x12\x04\xed\x05\x04\t\n\x0f\n\x07\
    \x04\x06\x04\0\x02C\x02\x12\x04\xed\x05\x0c\x0e\n\x1f\n\x06\x04\x06\x04\
    \0\x02D\x12\x04\xf0\x05\x04\x11\x1a\x0f\x20Foreign\x20words\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02D\x01\x12\x04\xf0\x05\x04\x0b\n\x0f\n\x07\x04\x06\
    \x04\0\x02D\x02\x12\x04\xf0\x05\x0e\x10\n\x19\n\x06\x04\x06\x04\0\x02E\
    \x12\x04\xf3\x05\x04\x0c\x1a\t\x20Keyword\n\n\x0f\n\x07\x04\x06\x04\0\
    \x02E\x01\x12\x04\xf3\x05\x04\x06\n\x0f\n\x07\x04\x06\x04\0\x02E\x02\x12\
    \x04\xf3\x05\t\x0b\n5\n\x06\x04\x06\x04\0\x02F\x12\x04\xf6\x05\x04\x0e\
    \x1a%\x20List\x20for\x20chains\x20of\x20comparable\x20items\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02F\x01\x12\x04\xf6\x05\x04\x08\n\x0f\n\x07\x04\x06\
    \x04\0\x02F\x02\x12\x04\xf6\x05\x0b\r\n$\n\x06\x04\x06\x04\0\x02G\x12\
    \x04\xf9\x05\x04\x0e\x1a\x14\x20Nominalized\x20clause\n\n\x0f\n\x07\x04\
    \x06\x04\0\x02G\x01\x12\x04\xf9\x05\x04\x08\n\x0f\n\x07\x04\x06\x04\0\
    \x02G\x02\x12\x04\xf9\x05\x0b\r\n-\n\x06\x04\x06\x04\0\x02H\x12\x04\xfc\
    \x05\x04\x12\x1a\x1d\x20Nominalized\x20clausal\x20subject\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02H\x01\x12\x04\xfc\x05\x04\x0c\n\x0f\n\x07\x04\x06\x04\
    \0\x02H\x02\x12\x04\xfc\x05\x0f\x11\n-\n\x06\x04\x06\x04\0\x02I\x12\x04\
    \xff\x05\x04\x16\x1a\x1d\x20Nominalized\x20clausal\x20passive\n\n\x0f\n\
    \x07\x04\x06\x04\0\x02I\x01\x12\x04\xff\x05\x04\x10\n\x0f\n\x07\x04\x06\
    \x04\0\x02I\x02\x12\x04\xff\x05\x13\x15\n.\n\x06\x04\x06\x04\0\x02J\x12\
    \x04\x82\x06\x04\x0e\x1a\x1e\x20Compound\x20of\x20numeric\x20modifier\n\
    \n\x0f\n\x07\x04\x06\x04\0\x02J\x01\x12\x04\x82\x06\x04\x08\n\x0f\n\x07\
    \x04\x06\x04\0\x02J\x02\x12\x04\x82\x06\x0b\r\n\x18\n\x06\x04\x06\x04\0\
    \x02K\x12\x04\x85\x06\x04\r\x1a\x08\x20Copula\n\n\x0f\n\x07\x04\x06\x04\
    \0\x02K\x01\x12\x04\x85\x06\x04\x07\n\x0f\n\x07\x04\x06\x04\0\x02K\x02\
    \x12\x04\x85\x06\n\x0c\nH\n\x06\x04\x06\x04\0\x02L\x12\x04\x88\x06\x04\
    \x14\x1a8\x20Dislocated\x20relation\x20(for\x20fronted/topicalized\x20el\
    ements)\n\n\x0f\n\x07\x04\x06\x04\0\x02L\x01\x12\x04\x88\x06\x04\x0e\n\
    \x0f\n\x07\x04\x06\x04\0\x02L\x02\x12\x04\x88\x06\x11\x13\n\x1f\n\x06\
    \x04\x06\x04\0\x02M\x12\x04\x8b\x06\x04\r\x1a\x0f\x20Aspect\x20marker\n\
    \n\x0f\n\x07\x04\x06\x04\0\x02M\x01\x12\x04\x8b\x06\x04\x07\n\x0f\n\x07\
    \x04\x06\x04\0\x02M\x02\x12\x04\x8b\x06\n\x0c\n#\n\x06\x04\x06\x04\0\x02\
    N\x12\x04\x8e\x06\x04\x0e\x1a\x13\x20Genitive\x20modifier\n\n\x0f\n\x07\
    \x04\x06\x04\0\x02N\x01\x12\x04\x8e\x06\x04\x08\n\x0f\n\x07\x04\x06\x04\
    \0\x02N\x02\x12\x04\x8e\x06\x0b\r\n!\n\x06\x04\x06\x04\0\x02O\x12\x04\
    \x91\x06\x04\x0e\x1a\x11\x20Genitive\x20object\n\n\x0f\n\x07\x04\x06\x04\
    \0\x02O\x01\x12\x04\x91\x06\x04\x08\n\x0f\n\x07\x04\x06\x04\0\x02O\x02\
    \x12\x04\x91\x06\x0b\r\n&\n\x06\x04\x06\x04\0\x02P\x12\x04\x94\x06\x04\
    \x10\x1a\x16\x20Infinitival\x20modifier\n\n\x0f\n\x07\x04\x06\x04\0\x02P\
    \x01\x12\x04\x94\x06\x04\n\n\x0f\n\x07\x04\x06\x04\0\x02P\x02\x12\x04\
    \x94\x06\r\x0f\n\x19\n\x06\x04\x06\x04\0\x02Q\x12\x04\x97\x06\x04\r\x1a\
    \t\x20Measure\n\n\x0f\n\x07\x04\x06\x04\0\x02Q\x01\x12\x04\x97\x06\x04\
    \x07\n\x0f\n\x07\x04\x06\x04\0\x02Q\x02\x12\x04\x97\x06\n\x0c\n.\n\x06\
    \x04\x06\x04\0\x02R\x12\x04\x9a\x06\x04\x0f\x1a\x1e\x20Nominal\x20comple\
    ment\x20of\x20a\x20noun\n\n\x0f\n\x07\x04\x06\x04\0\x02R\x01\x12\x04\x9a\
    \x06\x04\t\n\x0f\n\x07\x04\x06\x04\0\x02R\x02\x12\x04\x9a\x06\x0c\x0e\n\
    \xba\x02\n\x04\x04\x06\x02\0\x12\x04\xa2\x06\x02\x1d\x1a\xab\x02\x20Repr\
    esents\x20the\x20head\x20of\x20this\x20token\x20in\x20the\x20dependency\
    \x20tree.\n\x20This\x20is\x20the\x20index\x20of\x20the\x20token\x20which\
    \x20has\x20an\x20arc\x20going\x20to\x20this\x20token.\n\x20The\x20index\
    \x20is\x20the\x20position\x20of\x20the\x20token\x20in\x20the\x20array\
    \x20of\x20tokens\x20returned\n\x20by\x20the\x20API\x20method.\x20If\x20t\
    his\x20token\x20is\x20a\x20root\x20token,\x20then\x20the\n\x20`head_toke\
    n_index`\x20is\x20its\x20own\x20index.\n\n\x0f\n\x05\x04\x06\x02\0\x04\
    \x12\x06\xa2\x06\x02\x9b\x06\x03\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xa2\
    \x06\x02\x07\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xa2\x06\x08\x18\n\r\n\
    \x05\x04\x06\x02\0\x03\x12\x04\xa2\x06\x1b\x1c\n.\n\x04\x04\x06\x02\x01\
    \x12\x04\xa5\x06\x02\x12\x1a\x20\x20The\x20parse\x20label\x20for\x20the\
    \x20token.\n\n\x0f\n\x05\x04\x06\x02\x01\x04\x12\x06\xa5\x06\x02\xa2\x06\
    \x1d\n\r\n\x05\x04\x06\x02\x01\x06\x12\x04\xa5\x06\x02\x07\n\r\n\x05\x04\
    \x06\x02\x01\x01\x12\x04\xa5\x06\x08\r\n\r\n\x05\x04\x06\x02\x01\x03\x12\
    \x04\xa5\x06\x10\x11\no\n\x02\x04\x07\x12\x06\xaa\x06\0\xc2\x06\x01\x1aa\
    \x20Represents\x20a\x20mention\x20for\x20an\x20entity\x20in\x20the\x20te\
    xt.\x20Currently,\x20proper\x20noun\n\x20mentions\x20are\x20supported.\n\
    \n\x0b\n\x03\x04\x07\x01\x12\x04\xaa\x06\x08\x15\n2\n\x04\x04\x07\x04\0\
    \x12\x06\xac\x06\x02\xb5\x06\x03\x1a\"\x20The\x20supported\x20types\x20o\
    f\x20mentions.\n\n\r\n\x05\x04\x07\x04\0\x01\x12\x04\xac\x06\x07\x0b\n\
    \x19\n\x06\x04\x07\x04\0\x02\0\x12\x04\xae\x06\x04\x15\x1a\t\x20Unknown\
    \n\n\x0f\n\x07\x04\x07\x04\0\x02\0\x01\x12\x04\xae\x06\x04\x10\n\x0f\n\
    \x07\x04\x07\x04\0\x02\0\x02\x12\x04\xae\x06\x13\x14\n\x1d\n\x06\x04\x07\
    \x04\0\x02\x01\x12\x04\xb1\x06\x04\x0f\x1a\r\x20Proper\x20name\n\n\x0f\n\
    \x07\x04\x07\x04\0\x02\x01\x01\x12\x04\xb1\x06\x04\n\n\x0f\n\x07\x04\x07\
    \x04\0\x02\x01\x02\x12\x04\xb1\x06\r\x0e\n0\n\x06\x04\x07\x04\0\x02\x02\
    \x12\x04\xb4\x06\x04\x0f\x1a\x20\x20Common\x20noun\x20(or\x20noun\x20com\
    pound)\n\n\x0f\n\x07\x04\x07\x04\0\x02\x02\x01\x12\x04\xb4\x06\x04\n\n\
    \x0f\n\x07\x04\x07\x04\0\x02\x02\x02\x12\x04\xb4\x06\r\x0e\n!\n\x04\x04\
    \x07\x02\0\x12\x04\xb8\x06\x02\x14\x1a\x13\x20The\x20mention\x20text.\n\
    \n\x0f\n\x05\x04\x07\x02\0\x04\x12\x06\xb8\x06\x02\xb5\x06\x03\n\r\n\x05\
    \x04\x07\x02\0\x06\x12\x04\xb8\x06\x02\n\n\r\n\x05\x04\x07\x02\0\x01\x12\
    \x04\xb8\x06\x0b\x0f\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xb8\x06\x12\x13\
    \n/\n\x04\x04\x07\x02\x01\x12\x04\xbb\x06\x02\x10\x1a!\x20The\x20type\
    \x20of\x20the\x20entity\x20mention.\n\n\x0f\n\x05\x04\x07\x02\x01\x04\
    \x12\x06\xbb\x06\x02\xb8\x06\x14\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\
    \xbb\x06\x02\x06\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xbb\x06\x07\x0b\n\
    \r\n\x05\x04\x07\x02\x01\x03\x12\x04\xbb\x06\x0e\x0f\n\xc2\x02\n\x04\x04\
    \x07\x02\x02\x12\x04\xc1\x06\x02\x1a\x1a\xb3\x02\x20For\x20calls\x20to\
    \x20[AnalyzeEntitySentiment][]\x20or\x20if\n\x20[AnnotateTextRequest.Fea\
    tures.extract_entity_sentiment][google.cloud.language.v1.AnnotateTextReq\
    uest.Features.extract_entity_sentiment]\x20is\x20set\x20to\n\x20true,\
    \x20this\x20field\x20will\x20contain\x20the\x20sentiment\x20expressed\
    \x20for\x20this\x20mention\x20of\n\x20the\x20entity\x20in\x20the\x20prov\
    ided\x20document.\n\n\x0f\n\x05\x04\x07\x02\x02\x04\x12\x06\xc1\x06\x02\
    \xbb\x06\x10\n\r\n\x05\x04\x07\x02\x02\x06\x12\x04\xc1\x06\x02\x0b\n\r\n\
    \x05\x04\x07\x02\x02\x01\x12\x04\xc1\x06\x0c\x15\n\r\n\x05\x04\x07\x02\
    \x02\x03\x12\x04\xc1\x06\x18\x19\n3\n\x02\x04\x08\x12\x06\xc5\x06\0\xcc\
    \x06\x01\x1a%\x20Represents\x20an\x20output\x20piece\x20of\x20text.\n\n\
    \x0b\n\x03\x04\x08\x01\x12\x04\xc5\x06\x08\x10\n/\n\x04\x04\x08\x02\0\
    \x12\x04\xc7\x06\x02\x15\x1a!\x20The\x20content\x20of\x20the\x20output\
    \x20text.\n\n\x0f\n\x05\x04\x08\x02\0\x04\x12\x06\xc7\x06\x02\xc5\x06\
    \x12\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xc7\x06\x02\x08\n\r\n\x05\x04\
    \x08\x02\0\x01\x12\x04\xc7\x06\t\x10\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\
    \xc7\x06\x13\x14\n\xc6\x01\n\x04\x04\x08\x02\x01\x12\x04\xcb\x06\x02\x19\
    \x1a\xb7\x01\x20The\x20API\x20calculates\x20the\x20beginning\x20offset\
    \x20of\x20the\x20content\x20in\x20the\x20original\n\x20document\x20accor\
    ding\x20to\x20the\x20[EncodingType][google.cloud.language.v1.EncodingTyp\
    e]\x20specified\x20in\x20the\x20API\x20request.\n\n\x0f\n\x05\x04\x08\
    \x02\x01\x04\x12\x06\xcb\x06\x02\xc7\x06\x15\n\r\n\x05\x04\x08\x02\x01\
    \x05\x12\x04\xcb\x06\x02\x07\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xcb\
    \x06\x08\x14\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xcb\x06\x17\x18\nH\n\
    \x02\x04\t\x12\x06\xcf\x06\0\xd6\x06\x01\x1a:\x20Represents\x20a\x20cate\
    gory\x20returned\x20from\x20the\x20text\x20classifier.\n\n\x0b\n\x03\x04\
    \t\x01\x12\x04\xcf\x06\x08\x1e\nC\n\x04\x04\t\x02\0\x12\x04\xd1\x06\x02\
    \x12\x1a5\x20The\x20name\x20of\x20the\x20category\x20representing\x20the\
    \x20document.\n\n\x0f\n\x05\x04\t\x02\0\x04\x12\x06\xd1\x06\x02\xcf\x06\
    \x20\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xd1\x06\x02\x08\n\r\n\x05\x04\t\
    \x02\0\x01\x12\x04\xd1\x06\t\r\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xd1\x06\
    \x10\x11\n\x9c\x01\n\x04\x04\t\x02\x01\x12\x04\xd5\x06\x02\x17\x1a\x8d\
    \x01\x20The\x20classifier's\x20confidence\x20of\x20the\x20category.\x20N\
    umber\x20represents\x20how\x20certain\n\x20the\x20classifier\x20is\x20th\
    at\x20this\x20category\x20represents\x20the\x20given\x20text.\n\n\x0f\n\
    \x05\x04\t\x02\x01\x04\x12\x06\xd5\x06\x02\xd1\x06\x12\n\r\n\x05\x04\t\
    \x02\x01\x05\x12\x04\xd5\x06\x02\x07\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\
    \xd5\x06\x08\x12\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xd5\x06\x15\x16\n7\
    \n\x02\x04\n\x12\x06\xd9\x06\0\xdf\x06\x01\x1a)\x20The\x20sentiment\x20a\
    nalysis\x20request\x20message.\n\n\x0b\n\x03\x04\n\x01\x12\x04\xd9\x06\
    \x08\x1f\n\x1f\n\x04\x04\n\x02\0\x12\x04\xdb\x06\x02\x18\x1a\x11\x20Inpu\
    t\x20document.\n\n\x0f\n\x05\x04\n\x02\0\x04\x12\x06\xdb\x06\x02\xd9\x06\
    !\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xdb\x06\x02\n\n\r\n\x05\x04\n\x02\0\
    \x01\x12\x04\xdb\x06\x0b\x13\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xdb\x06\
    \x16\x17\nP\n\x04\x04\n\x02\x01\x12\x04\xde\x06\x02!\x1aB\x20The\x20enco\
    ding\x20type\x20used\x20by\x20the\x20API\x20to\x20calculate\x20sentence\
    \x20offsets.\n\n\x0f\n\x05\x04\n\x02\x01\x04\x12\x06\xde\x06\x02\xdb\x06\
    \x18\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\xde\x06\x02\x0e\n\r\n\x05\x04\n\
    \x02\x01\x01\x12\x04\xde\x06\x0f\x1c\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\
    \xde\x06\x1f\x20\n8\n\x02\x04\x0b\x12\x06\xe2\x06\0\xed\x06\x01\x1a*\x20\
    The\x20sentiment\x20analysis\x20response\x20message.\n\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xe2\x06\x08\x20\n<\n\x04\x04\x0b\x02\0\x12\x04\xe4\x06\
    \x02#\x1a.\x20The\x20overall\x20sentiment\x20of\x20the\x20input\x20docum\
    ent.\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\xe4\x06\x02\xe2\x06\"\n\r\n\
    \x05\x04\x0b\x02\0\x06\x12\x04\xe4\x06\x02\x0b\n\r\n\x05\x04\x0b\x02\0\
    \x01\x12\x04\xe4\x06\x0c\x1e\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xe4\x06\
    !\"\n\x83\x02\n\x04\x04\x0b\x02\x01\x12\x04\xe9\x06\x02\x16\x1a\xf4\x01\
    \x20The\x20language\x20of\x20the\x20text,\x20which\x20will\x20be\x20the\
    \x20same\x20as\x20the\x20language\x20specified\n\x20in\x20the\x20request\
    \x20or,\x20if\x20not\x20specified,\x20the\x20automatically-detected\x20l\
    anguage.\n\x20See\x20[Document.language][google.cloud.language.v1.Docume\
    nt.language]\x20field\x20for\x20more\x20details.\n\n\x0f\n\x05\x04\x0b\
    \x02\x01\x04\x12\x06\xe9\x06\x02\xe4\x06#\n\r\n\x05\x04\x0b\x02\x01\x05\
    \x12\x04\xe9\x06\x02\x08\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xe9\x06\t\
    \x11\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xe9\x06\x14\x15\nD\n\x04\x04\
    \x0b\x02\x02\x12\x04\xec\x06\x02\"\x1a6\x20The\x20sentiment\x20for\x20al\
    l\x20the\x20sentences\x20in\x20the\x20document.\n\n\r\n\x05\x04\x0b\x02\
    \x02\x04\x12\x04\xec\x06\x02\n\n\r\n\x05\x04\x0b\x02\x02\x06\x12\x04\xec\
    \x06\x0b\x13\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\xec\x06\x14\x1d\n\r\n\
    \x05\x04\x0b\x02\x02\x03\x12\x04\xec\x06\x20!\nD\n\x02\x04\x0c\x12\x06\
    \xf0\x06\0\xf6\x06\x01\x1a6\x20The\x20entity-level\x20sentiment\x20analy\
    sis\x20request\x20message.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xf0\x06\x08\
    %\n\x1f\n\x04\x04\x0c\x02\0\x12\x04\xf2\x06\x02\x18\x1a\x11\x20Input\x20\
    document.\n\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xf2\x06\x02\xf0\x06'\n\
    \r\n\x05\x04\x0c\x02\0\x06\x12\x04\xf2\x06\x02\n\n\r\n\x05\x04\x0c\x02\0\
    \x01\x12\x04\xf2\x06\x0b\x13\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xf2\x06\
    \x16\x17\nG\n\x04\x04\x0c\x02\x01\x12\x04\xf5\x06\x02!\x1a9\x20The\x20en\
    coding\x20type\x20used\x20by\x20the\x20API\x20to\x20calculate\x20offsets\
    .\n\n\x0f\n\x05\x04\x0c\x02\x01\x04\x12\x06\xf5\x06\x02\xf2\x06\x18\n\r\
    \n\x05\x04\x0c\x02\x01\x06\x12\x04\xf5\x06\x02\x0e\n\r\n\x05\x04\x0c\x02\
    \x01\x01\x12\x04\xf5\x06\x0f\x1c\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\
    \xf5\x06\x1f\x20\nE\n\x02\x04\r\x12\x06\xf9\x06\0\x81\x07\x01\x1a7\x20Th\
    e\x20entity-level\x20sentiment\x20analysis\x20response\x20message.\n\n\
    \x0b\n\x03\x04\r\x01\x12\x04\xf9\x06\x08&\nY\n\x04\x04\r\x02\0\x12\x04\
    \xfb\x06\x02\x1f\x1aK\x20The\x20recognized\x20entities\x20in\x20the\x20i\
    nput\x20document\x20with\x20associated\x20sentiments.\n\n\r\n\x05\x04\r\
    \x02\0\x04\x12\x04\xfb\x06\x02\n\n\r\n\x05\x04\r\x02\0\x06\x12\x04\xfb\
    \x06\x0b\x11\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xfb\x06\x12\x1a\n\r\n\x05\
    \x04\r\x02\0\x03\x12\x04\xfb\x06\x1d\x1e\n\x83\x02\n\x04\x04\r\x02\x01\
    \x12\x04\x80\x07\x02\x16\x1a\xf4\x01\x20The\x20language\x20of\x20the\x20\
    text,\x20which\x20will\x20be\x20the\x20same\x20as\x20the\x20language\x20\
    specified\n\x20in\x20the\x20request\x20or,\x20if\x20not\x20specified,\
    \x20the\x20automatically-detected\x20language.\n\x20See\x20[Document.lan\
    guage][google.cloud.language.v1.Document.language]\x20field\x20for\x20mo\
    re\x20details.\n\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\x80\x07\x02\xfb\
    \x06\x1f\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x80\x07\x02\x08\n\r\n\x05\
    \x04\r\x02\x01\x01\x12\x04\x80\x07\t\x11\n\r\n\x05\x04\r\x02\x01\x03\x12\
    \x04\x80\x07\x14\x15\n4\n\x02\x04\x0e\x12\x06\x84\x07\0\x8a\x07\x01\x1a&\
    \x20The\x20entity\x20analysis\x20request\x20message.\n\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\x84\x07\x08\x1e\n\x1f\n\x04\x04\x0e\x02\0\x12\x04\x86\
    \x07\x02\x18\x1a\x11\x20Input\x20document.\n\n\x0f\n\x05\x04\x0e\x02\0\
    \x04\x12\x06\x86\x07\x02\x84\x07\x20\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\
    \x86\x07\x02\n\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x86\x07\x0b\x13\n\r\n\
    \x05\x04\x0e\x02\0\x03\x12\x04\x86\x07\x16\x17\nG\n\x04\x04\x0e\x02\x01\
    \x12\x04\x89\x07\x02!\x1a9\x20The\x20encoding\x20type\x20used\x20by\x20t\
    he\x20API\x20to\x20calculate\x20offsets.\n\n\x0f\n\x05\x04\x0e\x02\x01\
    \x04\x12\x06\x89\x07\x02\x86\x07\x18\n\r\n\x05\x04\x0e\x02\x01\x06\x12\
    \x04\x89\x07\x02\x0e\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x89\x07\x0f\
    \x1c\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\x89\x07\x1f\x20\n5\n\x02\x04\
    \x0f\x12\x06\x8d\x07\0\x95\x07\x01\x1a'\x20The\x20entity\x20analysis\x20\
    response\x20message.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\x8d\x07\x08\x1f\n\
    >\n\x04\x04\x0f\x02\0\x12\x04\x8f\x07\x02\x1f\x1a0\x20The\x20recognized\
    \x20entities\x20in\x20the\x20input\x20document.\n\n\r\n\x05\x04\x0f\x02\
    \0\x04\x12\x04\x8f\x07\x02\n\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\x8f\x07\
    \x0b\x11\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x8f\x07\x12\x1a\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\x8f\x07\x1d\x1e\n\x83\x02\n\x04\x04\x0f\x02\
    \x01\x12\x04\x94\x07\x02\x16\x1a\xf4\x01\x20The\x20language\x20of\x20the\
    \x20text,\x20which\x20will\x20be\x20the\x20same\x20as\x20the\x20language\
    \x20specified\n\x20in\x20the\x20request\x20or,\x20if\x20not\x20specified\
    ,\x20the\x20automatically-detected\x20language.\n\x20See\x20[Document.la\
    nguage][google.cloud.language.v1.Document.language]\x20field\x20for\x20m\
    ore\x20details.\n\n\x0f\n\x05\x04\x0f\x02\x01\x04\x12\x06\x94\x07\x02\
    \x8f\x07\x1f\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x94\x07\x02\x08\n\r\n\
    \x05\x04\x0f\x02\x01\x01\x12\x04\x94\x07\t\x11\n\r\n\x05\x04\x0f\x02\x01\
    \x03\x12\x04\x94\x07\x14\x15\n4\n\x02\x04\x10\x12\x06\x98\x07\0\x9e\x07\
    \x01\x1a&\x20The\x20syntax\x20analysis\x20request\x20message.\n\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\x98\x07\x08\x1c\n\x1f\n\x04\x04\x10\x02\0\x12\
    \x04\x9a\x07\x02\x18\x1a\x11\x20Input\x20document.\n\n\x0f\n\x05\x04\x10\
    \x02\0\x04\x12\x06\x9a\x07\x02\x98\x07\x1e\n\r\n\x05\x04\x10\x02\0\x06\
    \x12\x04\x9a\x07\x02\n\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x9a\x07\x0b\
    \x13\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x9a\x07\x16\x17\nG\n\x04\x04\
    \x10\x02\x01\x12\x04\x9d\x07\x02!\x1a9\x20The\x20encoding\x20type\x20use\
    d\x20by\x20the\x20API\x20to\x20calculate\x20offsets.\n\n\x0f\n\x05\x04\
    \x10\x02\x01\x04\x12\x06\x9d\x07\x02\x9a\x07\x18\n\r\n\x05\x04\x10\x02\
    \x01\x06\x12\x04\x9d\x07\x02\x0e\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \x9d\x07\x0f\x1c\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x9d\x07\x1f\x20\n\
    5\n\x02\x04\x11\x12\x06\xa1\x07\0\xac\x07\x01\x1a'\x20The\x20syntax\x20a\
    nalysis\x20response\x20message.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xa1\
    \x07\x08\x1d\n0\n\x04\x04\x11\x02\0\x12\x04\xa3\x07\x02\"\x1a\"\x20Sente\
    nces\x20in\x20the\x20input\x20document.\n\n\r\n\x05\x04\x11\x02\0\x04\
    \x12\x04\xa3\x07\x02\n\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\xa3\x07\x0b\
    \x13\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xa3\x07\x14\x1d\n\r\n\x05\x04\
    \x11\x02\0\x03\x12\x04\xa3\x07\x20!\nV\n\x04\x04\x11\x02\x01\x12\x04\xa6\
    \x07\x02\x1c\x1aH\x20Tokens,\x20along\x20with\x20their\x20syntactic\x20i\
    nformation,\x20in\x20the\x20input\x20document.\n\n\r\n\x05\x04\x11\x02\
    \x01\x04\x12\x04\xa6\x07\x02\n\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\xa6\
    \x07\x0b\x10\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xa6\x07\x11\x17\n\r\n\
    \x05\x04\x11\x02\x01\x03\x12\x04\xa6\x07\x1a\x1b\n\x83\x02\n\x04\x04\x11\
    \x02\x02\x12\x04\xab\x07\x02\x16\x1a\xf4\x01\x20The\x20language\x20of\
    \x20the\x20text,\x20which\x20will\x20be\x20the\x20same\x20as\x20the\x20l\
    anguage\x20specified\n\x20in\x20the\x20request\x20or,\x20if\x20not\x20sp\
    ecified,\x20the\x20automatically-detected\x20language.\n\x20See\x20[Docu\
    ment.language][google.cloud.language.v1.Document.language]\x20field\x20f\
    or\x20more\x20details.\n\n\x0f\n\x05\x04\x11\x02\x02\x04\x12\x06\xab\x07\
    \x02\xa6\x07\x1c\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xab\x07\x02\x08\n\
    \r\n\x05\x04\x11\x02\x02\x01\x12\x04\xab\x07\t\x11\n\r\n\x05\x04\x11\x02\
    \x02\x03\x12\x04\xab\x07\x14\x15\n<\n\x02\x04\x12\x12\x06\xaf\x07\0\xb2\
    \x07\x01\x1a.\x20The\x20document\x20classification\x20request\x20message\
    .\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xaf\x07\x08\x1b\n\x1f\n\x04\x04\x12\
    \x02\0\x12\x04\xb1\x07\x02\x18\x1a\x11\x20Input\x20document.\n\n\x0f\n\
    \x05\x04\x12\x02\0\x04\x12\x06\xb1\x07\x02\xaf\x07\x1d\n\r\n\x05\x04\x12\
    \x02\0\x06\x12\x04\xb1\x07\x02\n\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xb1\
    \x07\x0b\x13\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xb1\x07\x16\x17\n=\n\
    \x02\x04\x13\x12\x06\xb5\x07\0\xb8\x07\x01\x1a/\x20The\x20document\x20cl\
    assification\x20response\x20message.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \xb5\x07\x08\x1c\n;\n\x04\x04\x13\x02\0\x12\x04\xb7\x07\x021\x1a-\x20Cat\
    egories\x20representing\x20the\x20input\x20document.\n\n\r\n\x05\x04\x13\
    \x02\0\x04\x12\x04\xb7\x07\x02\n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xb7\
    \x07\x0b!\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xb7\x07\",\n\r\n\x05\x04\
    \x13\x02\0\x03\x12\x04\xb7\x07/0\n\x9b\x01\n\x02\x04\x14\x12\x06\xbc\x07\
    \0\xd8\x07\x01\x1a\x8c\x01\x20The\x20request\x20message\x20for\x20the\
    \x20text\x20annotation\x20API,\x20which\x20can\x20perform\x20multiple\n\
    \x20analysis\x20types\x20(sentiment,\x20entities,\x20and\x20syntax)\x20i\
    n\x20one\x20call.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\xbc\x07\x08\x1b\n\
    \xa3\x01\n\x04\x04\x14\x03\0\x12\x06\xbf\x07\x02\xce\x07\x03\x1a\x92\x01\
    \x20All\x20available\x20features\x20for\x20sentiment,\x20syntax,\x20and\
    \x20semantic\x20analysis.\n\x20Setting\x20each\x20one\x20to\x20true\x20w\
    ill\x20enable\x20that\x20specific\x20analysis\x20for\x20the\x20input.\n\
    \n\r\n\x05\x04\x14\x03\0\x01\x12\x04\xbf\x07\n\x12\n-\n\x06\x04\x14\x03\
    \0\x02\0\x12\x04\xc1\x07\x04\x1c\x1a\x1d\x20Extract\x20syntax\x20informa\
    tion.\n\n\x11\n\x07\x04\x14\x03\0\x02\0\x04\x12\x06\xc1\x07\x04\xbf\x07\
    \x14\n\x0f\n\x07\x04\x14\x03\0\x02\0\x05\x12\x04\xc1\x07\x04\x08\n\x0f\n\
    \x07\x04\x14\x03\0\x02\0\x01\x12\x04\xc1\x07\t\x17\n\x0f\n\x07\x04\x14\
    \x03\0\x02\0\x03\x12\x04\xc1\x07\x1a\x1b\n#\n\x06\x04\x14\x03\0\x02\x01\
    \x12\x04\xc4\x07\x04\x1e\x1a\x13\x20Extract\x20entities.\n\n\x11\n\x07\
    \x04\x14\x03\0\x02\x01\x04\x12\x06\xc4\x07\x04\xc1\x07\x1c\n\x0f\n\x07\
    \x04\x14\x03\0\x02\x01\x05\x12\x04\xc4\x07\x04\x08\n\x0f\n\x07\x04\x14\
    \x03\0\x02\x01\x01\x12\x04\xc4\x07\t\x19\n\x0f\n\x07\x04\x14\x03\0\x02\
    \x01\x03\x12\x04\xc4\x07\x1c\x1d\n3\n\x06\x04\x14\x03\0\x02\x02\x12\x04\
    \xc7\x07\x04(\x1a#\x20Extract\x20document-level\x20sentiment.\n\n\x11\n\
    \x07\x04\x14\x03\0\x02\x02\x04\x12\x06\xc7\x07\x04\xc4\x07\x1e\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x02\x05\x12\x04\xc7\x07\x04\x08\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x02\x01\x12\x04\xc7\x07\t#\n\x0f\n\x07\x04\x14\x03\0\x02\
    \x02\x03\x12\x04\xc7\x07&'\nB\n\x06\x04\x14\x03\0\x02\x03\x12\x04\xca\
    \x07\x04&\x1a2\x20Extract\x20entities\x20and\x20their\x20associated\x20s\
    entiment.\n\n\x11\n\x07\x04\x14\x03\0\x02\x03\x04\x12\x06\xca\x07\x04\
    \xc7\x07(\n\x0f\n\x07\x04\x14\x03\0\x02\x03\x05\x12\x04\xca\x07\x04\x08\
    \n\x0f\n\x07\x04\x14\x03\0\x02\x03\x01\x12\x04\xca\x07\t!\n\x0f\n\x07\
    \x04\x14\x03\0\x02\x03\x03\x12\x04\xca\x07$%\n=\n\x06\x04\x14\x03\0\x02\
    \x04\x12\x04\xcd\x07\x04\x1b\x1a-\x20Classify\x20the\x20full\x20document\
    \x20into\x20categories.\n\n\x11\n\x07\x04\x14\x03\0\x02\x04\x04\x12\x06\
    \xcd\x07\x04\xca\x07&\n\x0f\n\x07\x04\x14\x03\0\x02\x04\x05\x12\x04\xcd\
    \x07\x04\x08\n\x0f\n\x07\x04\x14\x03\0\x02\x04\x01\x12\x04\xcd\x07\t\x16\
    \n\x0f\n\x07\x04\x14\x03\0\x02\x04\x03\x12\x04\xcd\x07\x19\x1a\n\x1f\n\
    \x04\x04\x14\x02\0\x12\x04\xd1\x07\x02\x18\x1a\x11\x20Input\x20document.\
    \n\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\xd1\x07\x02\xce\x07\x03\n\r\n\
    \x05\x04\x14\x02\0\x06\x12\x04\xd1\x07\x02\n\n\r\n\x05\x04\x14\x02\0\x01\
    \x12\x04\xd1\x07\x0b\x13\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xd1\x07\x16\
    \x17\n%\n\x04\x04\x14\x02\x01\x12\x04\xd4\x07\x02\x18\x1a\x17\x20The\x20\
    enabled\x20features.\n\n\x0f\n\x05\x04\x14\x02\x01\x04\x12\x06\xd4\x07\
    \x02\xd1\x07\x18\n\r\n\x05\x04\x14\x02\x01\x06\x12\x04\xd4\x07\x02\n\n\r\
    \n\x05\x04\x14\x02\x01\x01\x12\x04\xd4\x07\x0b\x13\n\r\n\x05\x04\x14\x02\
    \x01\x03\x12\x04\xd4\x07\x16\x17\nG\n\x04\x04\x14\x02\x02\x12\x04\xd7\
    \x07\x02!\x1a9\x20The\x20encoding\x20type\x20used\x20by\x20the\x20API\
    \x20to\x20calculate\x20offsets.\n\n\x0f\n\x05\x04\x14\x02\x02\x04\x12\
    \x06\xd7\x07\x02\xd4\x07\x18\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\xd7\
    \x07\x02\x0e\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xd7\x07\x0f\x1c\n\r\n\
    \x05\x04\x14\x02\x02\x03\x12\x04\xd7\x07\x1f\x20\n6\n\x02\x04\x15\x12\
    \x06\xdb\x07\0\xf5\x07\x01\x1a(\x20The\x20text\x20annotations\x20respons\
    e\x20message.\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xdb\x07\x08\x1c\n\xc5\
    \x01\n\x04\x04\x15\x02\0\x12\x04\xde\x07\x02\"\x1a\xb6\x01\x20Sentences\
    \x20in\x20the\x20input\x20document.\x20Populated\x20if\x20the\x20user\
    \x20enables\n\x20[AnnotateTextRequest.Features.extract_syntax][google.cl\
    oud.language.v1.AnnotateTextRequest.Features.extract_syntax].\n\n\r\n\
    \x05\x04\x15\x02\0\x04\x12\x04\xde\x07\x02\n\n\r\n\x05\x04\x15\x02\0\x06\
    \x12\x04\xde\x07\x0b\x13\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xde\x07\x14\
    \x1d\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xde\x07\x20!\n\xec\x01\n\x04\
    \x04\x15\x02\x01\x12\x04\xe3\x07\x02\x1c\x1a\xdd\x01\x20Tokens,\x20along\
    \x20with\x20their\x20syntactic\x20information,\x20in\x20the\x20input\x20\
    document.\n\x20Populated\x20if\x20the\x20user\x20enables\n\x20[AnnotateT\
    extRequest.Features.extract_syntax][google.cloud.language.v1.AnnotateTex\
    tRequest.Features.extract_syntax].\n\n\r\n\x05\x04\x15\x02\x01\x04\x12\
    \x04\xe3\x07\x02\n\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\xe3\x07\x0b\x10\
    \n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xe3\x07\x11\x17\n\r\n\x05\x04\x15\
    \x02\x01\x03\x12\x04\xe3\x07\x1a\x1b\n\xf1\x01\n\x04\x04\x15\x02\x02\x12\
    \x04\xe8\x07\x02\x1f\x1a\xe2\x01\x20Entities,\x20along\x20with\x20their\
    \x20semantic\x20information,\x20in\x20the\x20input\x20document.\n\x20Pop\
    ulated\x20if\x20the\x20user\x20enables\n\x20[AnnotateTextRequest.Feature\
    s.extract_entities][google.cloud.language.v1.AnnotateTextRequest.Feature\
    s.extract_entities].\n\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xe8\x07\x02\
    \n\n\r\n\x05\x04\x15\x02\x02\x06\x12\x04\xe8\x07\x0b\x11\n\r\n\x05\x04\
    \x15\x02\x02\x01\x12\x04\xe8\x07\x12\x1a\n\r\n\x05\x04\x15\x02\x02\x03\
    \x12\x04\xe8\x07\x1d\x1e\n\xe4\x01\n\x04\x04\x15\x02\x03\x12\x04\xec\x07\
    \x02#\x1a\xd5\x01\x20The\x20overall\x20sentiment\x20for\x20the\x20docume\
    nt.\x20Populated\x20if\x20the\x20user\x20enables\n\x20[AnnotateTextReque\
    st.Features.extract_document_sentiment][google.cloud.language.v1.Annotat\
    eTextRequest.Features.extract_document_sentiment].\n\n\x0f\n\x05\x04\x15\
    \x02\x03\x04\x12\x06\xec\x07\x02\xe8\x07\x1f\n\r\n\x05\x04\x15\x02\x03\
    \x06\x12\x04\xec\x07\x02\x0b\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xec\
    \x07\x0c\x1e\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\xec\x07!\"\n\x83\x02\
    \n\x04\x04\x15\x02\x04\x12\x04\xf1\x07\x02\x16\x1a\xf4\x01\x20The\x20lan\
    guage\x20of\x20the\x20text,\x20which\x20will\x20be\x20the\x20same\x20as\
    \x20the\x20language\x20specified\n\x20in\x20the\x20request\x20or,\x20if\
    \x20not\x20specified,\x20the\x20automatically-detected\x20language.\n\
    \x20See\x20[Document.language][google.cloud.language.v1.Document.languag\
    e]\x20field\x20for\x20more\x20details.\n\n\x0f\n\x05\x04\x15\x02\x04\x04\
    \x12\x06\xf1\x07\x02\xec\x07#\n\r\n\x05\x04\x15\x02\x04\x05\x12\x04\xf1\
    \x07\x02\x08\n\r\n\x05\x04\x15\x02\x04\x01\x12\x04\xf1\x07\t\x11\n\r\n\
    \x05\x04\x15\x02\x04\x03\x12\x04\xf1\x07\x14\x15\n<\n\x04\x04\x15\x02\
    \x05\x12\x04\xf4\x07\x021\x1a.\x20Categories\x20identified\x20in\x20the\
    \x20input\x20document.\n\n\r\n\x05\x04\x15\x02\x05\x04\x12\x04\xf4\x07\
    \x02\n\n\r\n\x05\x04\x15\x02\x05\x06\x12\x04\xf4\x07\x0b!\n\r\n\x05\x04\
    \x15\x02\x05\x01\x12\x04\xf4\x07\",\n\r\n\x05\x04\x15\x02\x05\x03\x12\
    \x04\xf4\x07/0\n\xc2\x02\n\x02\x05\0\x12\x06\xfc\x07\0\x8f\x08\x01\x1a\
    \xb3\x02\x20Represents\x20the\x20text\x20encoding\x20that\x20the\x20call\
    er\x20uses\x20to\x20process\x20the\x20output.\n\x20Providing\x20an\x20`E\
    ncodingType`\x20is\x20recommended\x20because\x20the\x20API\x20provides\
    \x20the\n\x20beginning\x20offsets\x20for\x20various\x20outputs,\x20such\
    \x20as\x20tokens\x20and\x20mentions,\x20and\n\x20languages\x20that\x20na\
    tively\x20use\x20different\x20text\x20encodings\x20may\x20access\x20offs\
    ets\n\x20differently.\n\n\x0b\n\x03\x05\0\x01\x12\x04\xfc\x07\x05\x11\n\
    \x81\x01\n\x04\x05\0\x02\0\x12\x04\xff\x07\x02\x0b\x1as\x20If\x20`Encodi\
    ngType`\x20is\x20not\x20specified,\x20encoding-dependent\x20information\
    \x20(such\x20as\n\x20`begin_offset`)\x20will\x20be\x20set\x20at\x20`-1`.\
    \n\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xff\x07\x02\x06\n\r\n\x05\x05\0\x02\
    \0\x02\x12\x04\xff\x07\t\n\n\xc8\x01\n\x04\x05\0\x02\x01\x12\x04\x84\x08\
    \x02\x0b\x1a\xb9\x01\x20Encoding-dependent\x20information\x20(such\x20as\
    \x20`begin_offset`)\x20is\x20calculated\x20based\n\x20on\x20the\x20UTF-8\
    \x20encoding\x20of\x20the\x20input.\x20C++\x20and\x20Go\x20are\x20exampl\
    es\x20of\x20languages\n\x20that\x20use\x20this\x20encoding\x20natively.\
    \n\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\x84\x08\x02\x06\n\r\n\x05\x05\0\
    \x02\x01\x02\x12\x04\x84\x08\t\n\n\xd2\x01\n\x04\x05\0\x02\x02\x12\x04\
    \x89\x08\x02\x0c\x1a\xc3\x01\x20Encoding-dependent\x20information\x20(su\
    ch\x20as\x20`begin_offset`)\x20is\x20calculated\x20based\n\x20on\x20the\
    \x20UTF-16\x20encoding\x20of\x20the\x20input.\x20Java\x20and\x20Javascri\
    pt\x20are\x20examples\x20of\n\x20languages\x20that\x20use\x20this\x20enc\
    oding\x20natively.\n\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\x89\x08\x02\x07\
    \n\r\n\x05\x05\0\x02\x02\x02\x12\x04\x89\x08\n\x0b\n\xc8\x01\n\x04\x05\0\
    \x02\x03\x12\x04\x8e\x08\x02\x0c\x1a\xb9\x01\x20Encoding-dependent\x20in\
    formation\x20(such\x20as\x20`begin_offset`)\x20is\x20calculated\x20based\
    \n\x20on\x20the\x20UTF-32\x20encoding\x20of\x20the\x20input.\x20Python\
    \x20is\x20an\x20example\x20of\x20a\x20language\n\x20that\x20uses\x20this\
    \x20encoding\x20natively.\n\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\x8e\x08\
    \x02\x07\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\x8e\x08\n\x0bb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
